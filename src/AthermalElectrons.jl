"""
    athemdistribution_factory(sim::Simulation,laser::Expr)
    This function takes the Simulation struct and a laser expression and returns an assembled
    expression for how the AthEM non-equilibrium electrons should propagate.
"""
function athemdistribution_factory(sim::Simulation,laser_expr::Expr)
    feq = :(FermiDirac(Tel,μ,sim.structure.egrid))
    ftot = :($feq.+fneq)
    Elecelec = athem_electronelectroninteraction(sim)
    Elecphon = athem_electronphononinteraction(sim)
    M = athemexcitation_matrixelements(sim)
    athemexcite=:($laser_expr*Lightmatter.athemexcitation($ftot,sim.structure.egrid,DOS,sim.laser.hv,$M))
    return build_athemdistribution(sim,athemexcite,Elecelec,Elecphon)
end
"""
    build_athemdistribution(athemexcite::Expr,Elecelec::Expr,Elecphon::Expr)
    Takes 3 expressions for the excitaiton, electorn interaction and phonon interaction
    and returns a expr which is their broadcasted sum. All 3 compenents therefore need to be in
    a form where they can be summed e.g. negatives must be included in the original expression.
"""
function build_athemdistribution(sim::Simulation,athemexcite::Expr,Elecelec::Union{Expr,Real},Elecphon::Union{Expr,Real})
    args = (athemexcite,Elecelec,Elecphon)
    if sim.athermalelectrons.Conductivity == true
        push!(args,:f_cond)
    end
    return Expr(:call,:+,(args)...)
end
"""
    athemexcitation(ftot::Vector{<:Real},egrid::Vector{<:Real},DOS::spl,hv::Real,M::Union{Real,Vector{<:Real}}))
    Calculates the excitation of the non-equilibrium distribution at the current time
    step. Uses a Fermi's Golden Rule epxression to denote the change in the distribution for 
    the holes and electrons as well as ensures particle Constantservation between the two quasiparticles.
"""
function athemexcitation(ftot::Vector{<:Real},egrid::Vector{<:Real},DOS::spl,hv::Real,M::Union{Real,Vector{<:Real}})
    ftotspl = get_interpolant(egrid,ftot)
    Δfneqh = athem_holegeneration(egrid,DOS,ftotspl,hv,M)
    Δfneqe = athem_electrongeneration(egrid,DOS,ftotspl,hv,M)
    pc_sf = get_noparticles(Δfneqe,DOS,egrid) / get_noparticles(Δfneqh,DOS,egrid)
    Δfneqtot = Δfneqe.-(pc_sf*Δfneqh)
    return Δfneqtot./get_internalenergy(Δfneqtot,DOS,egrid)
end
"""
    athem_holegeneration(egrid::Vector{<:Real},DOS::spl,ftotspl::spl,hv::Real,M::Union{Real,Vector{<:Real}}))
    Calculates the distribution of holes generated by the excitation using a spline
    of the current total distribution (ftotspl) as f(E+hv) may not be a point on the discretized 
    energy grid.
"""
function athem_holegeneration(egrid::Vector{<:Real},DOS::spl,ftotspl::spl,hv::Real,M::Union{Real,Vector{<:Real}})
    return (2*pi/Constants.ħ) .* M .* DOS(egrid.+hv).*ftotspl(egrid).*(1 .-ftotspl(egrid.+hv))
end
"""
    athem_electrongeneration(egrid::Vector{<:Real},DOS::spl,ftotspl::spl,hv::Real,M::Union{Real,Vector{<:Real}})
    Calculates the distribution of electrons generated by the excitation using a spline
    of the current total distribution (ftotspl) as f(E+hv) may not be a point on the discretized 
    energy grid.
"""
function athem_electrongeneration(egrid::Vector{<:Real},DOS::spl,ftotspl::spl,hv::Real,M::Union{Real,Vector{<:Real}})
    return (2*pi/Constants.ħ) .* M .* DOS(egrid.-hv).*ftotspl(egrid.-hv).*(1 .-ftotspl(egrid))
end
"""
    athemexcitation_matrixelement(sim::Simulation)
    Returns an expression of the requested matrix element.
    :unity returns the 1.0 such that there is no matrix element 
"""
function athemexcitation_matrixelement(sim::Simulation)
    if sim.athermalelectrons.ExcitationMatrixElements == :unity
        return :(1.0)
    end
end
"""
    athem_electronelectroninteraction(sim::Simulation)
    Returns an expression for the hange in the non-equilibrium distribution due to the interaction with 
    thermal electrons. If none is requested then returns a 0.0. The keyword to be set in define_simulation_settings
    is elecelecint = true. The function assumes that there will be a phonon bath present so electemp must also equal true.
"""
function athem_electronelectroninteraction(sim::Simulation)
    if sim.athermalelectrons.AthermalElectron_ElectronCoupling == true 
        return :(-1*relax_dis)
    else
        return 0.0
    end
end
"""
    athem_electronelectronscattering(Tel::Real,μ::Real,mp::MaterialParameters,fneq::Vector{Real},DOS::spl,n::Real,τee::Union{Real,Vector{<:Real}})
    Calculates the change in fneq distribution to electron-electron scattering. This distribution is later referred to as 
    relax_dis. The method is via a modified relaxation time approximation where instead of -((fneq+feq)-frel)/τ we instead switch
    feq and frel to ensure that fneq relaxes to a fully 0 distribution. This is currently fixed to use a Fermi liquid relaxation
    time.
"""
function athem_electronelectronscattering(Tel::Real,μ::Real,sim::Simulation,fneq::Vector{<:Real},DOS::spl,n::Real,τee::Union{Real,Vector{<:Real}})
    feq = Lightmatter.FermiDirac(Tel,μ,sim.structure.egrid)
    ftot = feq.+fneq
    goal = extended_Bode(ftot.*DOS(sim.structure.egrid).*sim.structure.egrid,sim.structure.egrid)
    frel = find_relaxeddistribution(sim.structure.egrid,goal,n,DOS)
    return (fneq.+frel.-feq)./τee
end
"""
    electron_relaxationtime(sim::Simulation)
    Returns the requested expression for the electronic relaxation time. Either a constant given by simulation.athermalelectrons.τ
    or by the Fermi Liquid Theory relaxation time defined in https://arxiv.org/abs/2503.09479.
"""
function electron_relaxationtime(sim::Simulation)
    if sim.athermalelectrons.ElectronicRelaxation == :constant
        return :(sim.athermalelectrons.τ)
    elseif sim.athermalelectrons.ElectronicRelaxation == :FLT
        return :(sim.athermalelectrons.τ*(μ.+sim.athermalelectrons.FE)^2 ./((sim.structure.egrid.-μ).^2 .+(pi*Constants.kB*Tel)^2))
    end
end       
"""
    find_relaxeddistribution(egrid::Vector{<:Real},goal::Real,n::Real,DOS::spl,kB::Real)
    This is the function that performs the root finding to find a Fermi distribution with the same internal energy
    as the goal (the internal energy of ftot). This then returns said Fermi distribution.
"""
function find_relaxeddistribution(egrid::Vector{<:Real},goal::Real,n::Real,DOS::spl)
    f(u) = goal - find_temperatureandμ(u,n,DOS,egrid)
    Temp = solve(ZeroProblem(f,1000.0);abstol=1e-10,reltol=1e-10)
    μ = find_chemicalpotential(n,Temp,DOS,egrid)
    return FermiDirac(Temp,μ,egrid)
end
"""
    find_temperatureandμ(Tel::Real,n::Real,DOS::spl,egrid::Vector{<:Real})
    The function inside of the rootfinding problem which simply calculates the current μ from the temp suggested and returns
    the internal energy of the corresponding guess' Fermi distribution.
"""
function find_temperatureandμ(Tel::Real,n::Real,DOS::spl,egrid::Vector{<:Real})
    μ = find_chemicalpotential(n,Tel,DOS,egrid)
    return get_internalenergy(FermiDirac(Tel,μ,egrid),DOS,egrid)
end
"""
    athem_electronphononinteraction(sim::Simulation)
    Provides the expression for the chosen non-equilibrium electron-phonon interaction. This uses a relaxation time approach
    again with a Constantstant relaxation time provided in MaterialParameters. If none is requested then returns a 0.0. The keyword
    to be set in define_simulation_settings is elecphonint = true. The function assumes that there will be a phonon bath present 
    so phonontemp must also equal true.
"""
function athem_electronphononinteraction(sim::Simulation)
    if sim.athermalelectrons.AthermalElectron_PhononCoupling == true 
        τep = phonon_relaxationtime(sim)
        return :(-fneq./$τep)
    else
        return 0.0
    end
end
"""
    phonon_relaxationtime(sim::Simulation)
    Returns the requested expression for the electron-phonon relaxation time. Either a constant given by simulation.athermalelectrons.τep
    or by a quasiparticle relaxation time defined in E.Carpene, Phys. Rev. B., 2006, 74, 024301.
"""
function phonon_relaxationtime(sim::Simulation)
    if sim.athermalelectrons.PhononicRelaxation == :constant
        return :(sim.athermalelectrons.τep)
    elseif sim.athermalelectrons.PhononicRelaxation == :quasi
        return :(sim.electronictemperature.γ*(Tel+Tph)/(2*sim.electronictemperature.g))
    end
end  
"""
    athem_thermalelectronparticlechange(sim::Simulation)
    Returns an expression for the change in number of particles due to relax_dis plus a possilbe equilibration term if non-eq conductivity
    is also enabled.
"""
function athem_thermalelectronparticlechange(sim::Simulation)
    part_change = :(Lightmatter.get_noparticles(relax_dis,DOS,sim.structure.egrid))
    args = (part_change)
    if sim.athermalelectrons.Conductivity == true
        push!(args,:(n_cond[i]))
    end
    return Expr(:call,:+,args...)
end
"""
    electron_distribution_transport!(v_g::Vector{<:Real},f::AbstractArray{<:Real},Δf::AbstractArray{<:Real},dim::Dimension)
    Calculates the ballistic electron transport in electron distributions. If the type of the Dimension struct is Homogeneous 
    then there should be no conductivity and returns a zero array at every time step. 
"""
function electron_distribution_transport!(v_g::Vector{<:Real},f::AbstractArray{<:Real},Δf::AbstractArray{<:Real},dz::Real)
    for i in 2:size(f, 1)-1
        Δf[i,:] = (f[i-1,:] .- 2*f[i,:] .+ f[i+1,:]) ./ dz .* v_g
    end
    Δf[1,:] = -(f[1,:] .- f[2,:]) ./ dz .*v_g
    Δf[end,:] = (f[end-1,:] .- f[end,:]) ./ dz .* v_g
end
"""
    thermal_particle_transport(v_g::Vector{<:Real},egrid::Vector{<:Real},n::Vector{<:Real},Δn::Vector{<:Real},dim::Dimension)
    Provides a restoring force to the equilibrium particle distribution due to the the relaxation from non-eq electron to equilibrium
    electron occuring berfore particle equilibration in the non-thermal system when trasnport is enabled. Uses the fermi velocity as 
    the resotring velocity.
"""
function thermal_particle_transport(v_g::Vector{<:Real},egrid::Vector{<:Real},n::Vector{<:Real},Δn::Vector{<:Real},dim::Dimension)
    idx_0 = findmin(abs(egrid-0.0))[2]
    v_F = v_g[idx_0]
    for i in 2:dim.length -1
        Δn[i] = (n[i+1] - (2*n[i]) + n[i-1]) / dim.spacing * v_F
    end
    Δn[1] = (n[2] - n[1]) / dim.spacing * v_F
    Δn[end] = (n[end-1] - n[end]) / dim.spacing * v_F
    return Δn
end