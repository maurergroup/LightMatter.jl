<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · LightMatter.jl</title><meta name="title" content="API · LightMatter.jl"/><meta property="og:title" content="API · LightMatter.jl"/><meta property="twitter:title" content="API · LightMatter.jl"/><meta name="description" content="Documentation for LightMatter.jl."/><meta property="og:description" content="Documentation for LightMatter.jl."/><meta property="twitter:description" content="Documentation for LightMatter.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LightMatter.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../Tutorials/antennareactor/">Antenna Reactor Complex Simulation</a></li><li><a class="tocitem" href="../Tutorials/athem/">AthEM Simulation</a></li><li><a class="tocitem" href="../Tutorials/boltzmann/">Boltzmann Simulation</a></li><li><a class="tocitem" href="../Tutorials/dipoleapproximation/">Dipole Approximation Density Matrix Simulation</a></li><li><a class="tocitem" href="../Tutorials/surfaces/">Surface-Dependent Electronic Structure Simulation</a></li><li><a class="tocitem" href="../Tutorials/twotemperaturemodel/">1D Two-Temperature Model Simulation</a></li></ul></li><li><span class="tocitem">Systems</span><ul><li><a class="tocitem" href="../Systems/athermalelectrons/">Athermal Electrons</a></li><li><a class="tocitem" href="../Systems/densitymatrix/">Density Matrix</a></li><li><a class="tocitem" href="../Systems/electronicdistribution/">Electronic Distribution</a></li><li><a class="tocitem" href="../Systems/electronictemperature/">Electronic Temperature</a></li><li><a class="tocitem" href="../Systems/lasers/">Lasers </a></li><li><a class="tocitem" href="../Systems/phononicdistribution/">Phononic Distribution</a></li><li><a class="tocitem" href="../Systems/phononictemperature/">Phonon Temperature</a></li><li><a class="tocitem" href="../Systems/structure/">Structure</a></li></ul></li><li><a class="tocitem" href="../outputting/">Post Processing</a></li><li><a class="tocitem" href="../units/">Unit Management</a></li><li class="is-active"><a class="tocitem" href>API</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/maurergroup/LightMatter.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/maurergroup/LightMatter.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h3 id="Simulation-Types-and-Constructors"><a class="docs-heading-anchor" href="#Simulation-Types-and-Constructors">Simulation Types &amp; Constructors</a><a id="Simulation-Types-and-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Types-and-Constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.AthermalElectrons" href="#LightMatter.AthermalElectrons"><code>LightMatter.AthermalElectrons</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AthermalElectrons &lt;: SimulationTypes
    Enabled::Bool

    AthermalElectron_ElectronCoupling::Bool # Enables coupling to an electronic bath
    AthermalElectron_PhononCoupling::Bool # Enables coupling to a phononic bath
    Conductivity::Bool # Provides conductivity of a ballistic nature using velocity given by v_g
    EmbeddedAthEM::Bool #WIP!! Do not set to true

    ElectronicRelaxation::Symbol # Implementations are Fermi Liquid Theory (:FLT) or constant (:constant)
    PhononicRelaxation::Symbol # Implementations are constant (:constant) or quasiparticle scattering (:quasi)
    ExcitationMatrixElements::Symbol # Implementation is only match internal energy (:unity)
    Conductive_Velocity::Symbol # Implementation of how gorup velocity is calculated, :constant, :fermigas or :effectiveoneband
    
    FE::Union{Float64,Vector{Float64}} # Shifted Fermi energy to the bottom of the valence band for FLT relaxation and group velocity
    τ::Union{Float64,Vector{Float64}} # Material dependent scale-factor for :FLT relaxation time or the constant value for :constant
    τep::Union{Float64,Vector{Float64}} # Constant relaxation time for phonons
    v_g::Union{Vector{Float64},Matrix{Float64}} # Group velocity of electrons calculated assuming a Fermi liquid with μ = FE
end

Struct that defines and holds all values for the propagation of athermal electrons
Enabling this struct assumes an AthEM like system (https://arxiv.org/abs/2503.09479) so can be coupled to electronic
and phononic thermal baths. Coupling implicitly assumes the other system is enabled.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L252-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.DensityMatrix" href="#LightMatter.DensityMatrix"><code>LightMatter.DensityMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WIP!!!
DensityMatrix &lt;: SimulationTypes
    Enabled::Bool = false
end 

Struct that defines and holds all values for the density matrix propagation.
This Simulation object doesn&#39;t function or couple with the others due to the difference in propagation from coupled 
ODE to a von-Neumann equation.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L221-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.Dimension" href="#LightMatter.Dimension"><code>LightMatter.Dimension</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Dimension &lt;: SimulationTypes
    length::Int # The length of the grid, not the depth of the slab
    grid::AbstractArray{Float64} # The grid the simulation is solved over
    spacing::Union{Float64, Vector{Float64}} #The spacing between grid points
    InterfaceHeight::Union{Float64, Vector{Float64}} # Height sorted list of the interfaces between materials
end

Struct that contains all information regarding the spatial grid that the simulation is performed on.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L69-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.ElectronicDistribution" href="#LightMatter.ElectronicDistribution"><code>LightMatter.ElectronicDistribution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ElectronicDistribution &lt;: SimulationTypes
    Enabled::Bool = false

    Electron_PhononCoupling::Bool = false
end
Struct that defines and holds all values for the propagation of an electronic distribution</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L495-L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.ElectronicTemperature" href="#LightMatter.ElectronicTemperature"><code>LightMatter.ElectronicTemperature</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ElectronicTemperature &lt;: SimulationTypes
    Enabled::Bool = false

    AthermalElectron_ElectronCoupling::Bool = false # Enables coupling to athermal electrons
    Electron_PhononCoupling::Bool = false # Enables coupling to a phonon thermostat
    Conductivity::Bool = false # Provides diffusive thermal conductivity

    ElectronicHeatCapacity::Symbol = :linear # Whether to use linear (:linear), non-linear (:nonlinear) or constant :(constant)
                                             # electronic heat capacity
    ElectronPhononCouplingValue::Symbol = :constant # Whether to use constant (:constant) or variable (:variable)
                                                    # electron phonon coupling

    γ::Union{Float64,Vector{Float64}} = 1.0 # Specific heat capacity of electrons at room temperature for linear heat capacity
    κ::Union{Float64,Vector{Float64}} = 1.0 # Thermal conductivity of electrons at room temperature
    λ::Union{Float64,Vector{Float64}} = 1.0 # Electron-phonon mass enhancement factor for non-linear electron-phonon coupling
    ω::Union{Float64,Vector{Float64}} = 1.0 # Second moment of phonon spectral function for non-linear electron-phonon coupling
    g::Union{Float64,Vector{Float64}} = 1.0 # Constant electron-phonon coupling value 
end

Struct that defines and holds all values for the propagation of an electronic temperature
This can be coupled solely to a thermal phonon bath for a Two-Temperature Model simulation or to athermal electrons
for AthEM propagation with relaxation. Coupling implicitly assumes the other system is enabled.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L341-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.Fields" href="#LightMatter.Fields"><code>LightMatter.Fields</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Fields &lt;: SimulationTypes
    Electric::Expr # Expression for the magnitude of the electric field in the simulation
    Nagnetic::Expr # Expression for the magnitude of the magnetic field in the simulation
end

Struct that contains all information regarding electromagnetic fields in the simulation.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L110-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.Laser" href="#LightMatter.Laser"><code>LightMatter.Laser</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Laser &lt;: SimulationTypes
    envelope::Symbol = :Gaussian # Currently implemented are :Gaussian, :HyperbolicSecant, :Lorentzian and :Rectangular
    Transport::Symbol # :optical, :ballistic and :combined are the options for how the laser decays into a slab

    FWHM::Float64 # The Full-Width Half-Maximum of the laser, for rectnagular half the length
    ϕ::Float64 # The unabsorbed fluence of the laser
    hv::Float64 # The photon frequency of the laser
    ϵ::Union{Float64,Vector{Float64}} # The inverse of the absorption coefficient
    R::Float64 # The reflectivity of the sample
    δb::Union{Float64,Vector{Float64}} # The ballistic length of electrons
end

Struct that contains all laser parameters and any material parameters that affect laser absorption</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.PhononicDistribution" href="#LightMatter.PhononicDistribution"><code>LightMatter.PhononicDistribution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">W.I.P!!!
struct PhononicDistribution &lt;: SimulationTypes
    Enabled::Bool = false

    Electron_PhononCoupling::Bool = false
end
Struct that defines and holds all values for the propagation of a phononic distribution</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L537-L545">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.PhononicTemperature" href="#LightMatter.PhononicTemperature"><code>LightMatter.PhononicTemperature</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct PhononicTemperature &lt;: SimulationTypes
    Enabled::Bool = false

    AthermalElectron_PhononCoupling::Bool = false # Enables coupling to athermal electrons
    Electron_PhononCoupling::Bool = false # Enables coupling to an electron thermostat
    Conductivity::Bool = false # Provides diffusive thermal conductivity

    PhononicHeatCapacity::Symbol = :constant # Whether to use constant (:constant) or non-linear/Simpson&#39;s Rule (:nonlinear) 
                                             # Phononic Heat Capacity
    
    θ::Union{Float64,Vector{Float64}} = 1.0 # Debye temperature for non-linear phonon heat capacity
    n::Union{Float64,Vector{Float64}} = 1.0 # Atomic density for non-linear phonon heat capacity
    Cph::Union{Float64,Vector{Float64}} = 1.0 # Constant phonon heat capacity
    κ::Union{Float64,Vector{Float64}} = 1.0 # Constant phonon thermal conductivity
end
Struct that defines and holds all values for the propagation of a phononic temperature
This can be coupled solely to a thermal electronic bath for a Two-Temperature Model simulation or to athermal electrons
for AthEM propagation with phonon-relaxation. Coupling implicitly assumes the other system is enabled.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L428-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.Simulation" href="#LightMatter.Simulation"><code>LightMatter.Simulation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Simulation &lt;: SimulationTypes
    densitymatrix::DensityMatrix
    electronictemperature::ElectronicTemperature
    phononictemperature::PhononicTemperature
    athermalelectrons::AthermalElectrons
    electronicdistribution::ElectronicDistribution
    phononicdistribution::PhononicDistribution
    structure::Structure
    laser::Laser
end
This struct contains all the others and is the main simulation object both in assembling a simulation and during it</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L580-L592">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.SimulationTypes" href="#LightMatter.SimulationTypes"><code>LightMatter.SimulationTypes</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimulationTypes

Parent type of all subtypes in LightMatter.jl</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.Structure" href="#LightMatter.Structure"><code>LightMatter.Structure</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Structure &lt;: SimulationTypes
    Spatial_DOS::Bool # Whether to vary the DOS with height - if so the DOS becomes a vector

    Elemental_System::Int # The number of elemental systems, if &gt; 1 then each constant and vector
                        # of material parameters needs to become a vector of length=Elemental_System

    DOS::Union{spl,Vector{spl},Vector{Vector{spl}}} # The density of states of the simulation
    egrid::Vector{Float64} # An energy grid for electronic or phononic distributions to be solved on

    dimension::Union{Dimension} # A struct holding all spatial grid structure (0D or 1D)
    bandstructure::Union{Vector{&lt;:DataInterpolations.AkimaInterpolation}, Vector{&lt;:Vector{DataInterpolations.AkimaInterpolation}},Nothing} 
                    # The band structure of the simulation both in terms of k-&gt;E and E-&gt; k
end

Struct that contains any spatial information including the DOS, the spatial grid to solve the simulation on and
the elemental composition of the simulation (e.g. an antenna-reactor system would contain two elemental systems)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L140-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.TotalFields" href="#LightMatter.TotalFields"><code>LightMatter.TotalFields</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TotalFields &lt;: SimulationTypes
    laser::Fields # The laser fields in the simulation
    external::Fields # The external fields in the simulation, e.g. a magnetic field
end

Struct that contains both the field generated by the laser and any external fields.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L122-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.spl" href="#LightMatter.spl"><code>LightMatter.spl</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spl=Interpolations.AbstractExtrapolation

A convenience type definition to make type specificity easier throughout the code</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_AthermalElectrons-Tuple{}" href="#LightMatter.build_AthermalElectrons-Tuple{}"><code>LightMatter.build_AthermalElectrons</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_AthermalElectrons(;structure::Structure, Enabled = false, AthermalElectron_ElectronCoupling = false, 
                        AthermalElectron_PhononCoupling = false, Conductivity = false, ElectronicRelaxation = :FLT, 
                        PhononicRelaxation = :constant, ExcitationMatrixElements = :unity, FE=0.0, τ=1.0, τep = 1000.0, 
                        v_g = nothing, Conductive_Velocity = :constant, EmbeddedAthEM = false)

Outer constructor function to assemble the AthermalElectrons struct. Unit conversion is detected on all parameters.
The function will build the group veolcity if one isn&#39;t provided by the user.
Defaults allow any unneccessary parameters for users simulation to be ignored.

# Arguments
- &#39;Enabled&#39;: Bool for enabling an athermal electron subssystem
- &#39;structure&#39;: Structure struct, provide if you want the group velocity calculated for you
- &#39;AthermalElectron_ElectronCoupling&#39;: Enables athermal electron - thermal electron coupling
- &#39;AthermalElectron_PhononCoupling&#39;: Enables athermal electron - thermal phonon coupling
- &#39;Conductivity&#39;: Bool for enabling athermal electron ballistic transport
- &#39;ElectronicRelaxation&#39;: Method for calculating athermal electron lifetime due to e-e collisions, :FLT or :constant
- &#39;PhononicRelaxation&#39;: Method for calculating athermal electron lifetime due to e-p collisions, :quasi or :constant
- &#39;ExcitationMatrixElements&#39;: Decides method to calculate excitation matrix elements, only :unity is currently implemented
- &#39;FE&#39;: unit = eV: The Fermi energy defined as the difference between the bottom of the valence band in the DOS and 0.0
- &#39;τ&#39;: unit = fs: A material dependent scalar for the :FLT lifetime or the constant value for :constant e-e lifetime
- &#39;τep&#39;: unit = fs: The constant lifetime for the athermal electrons due to electron-phonon coupling
- &#39;v_g&#39;: unit = nm/fs: The group velocity of the ballistic electrons, for the user to define their own group velocity and will overwrite the 
         one calculated by build_group_velocity. Also the value used for a constant velocity.
- &#39;Conductive_Velocity&#39;: Define the group velocity that build_group_velocity should use, :constant :fermigas, :effectiveoneband
- &#39;EmbeddedAthEM&#39;: Bool for setting only the surface layer to AthEM and the rest a TTM. Can&#39;t be used alongside athermal electron
                   transport

# Returns
- The AthermalElectrons struct with the users settings and parameters with any neccessary unit conversion.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L294-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_DensityMatrix-Tuple{}" href="#LightMatter.build_DensityMatrix-Tuple{}"><code>LightMatter.build_DensityMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WIP!!!
build_DensityMatrix(; Enabled = false)

Once implemented will build a density matrix and store Hamiltonian for propagation via the vonNeumann equation.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L237-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_Dimension" href="#LightMatter.build_Dimension"><code>LightMatter.build_Dimension</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_Dimension(grid=[0.0]::AbstractArray{Float64}, cutoff=0.0::Union{Vector{Float64},Float64})

Outer constructor function to assemble the Dimension struct. The user provides an evenly spaced grid 
and sorted list of interface heights for antenna-reactor complexes. The user must ensure the length of 
cutoff = Elemental_System - 1. No unit conversion is performed when assembling this struct.
Defaults allow any unneccessary parameters for users simulation to be ignored.

# Arguments
- &#39;grid&#39;: unit = nm: Vector representing spatial grid. If [0.0] then homogenous (0D) calculation is performed
- &#39;cutoff&#39;: unit = nm:  Sorted list of all interface heights. Only used when Elemental_System &gt; 1. 

# Returns
- The Dimension struct with the users grid and interface heights</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L85-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_ElectronicDistribution-Tuple{}" href="#LightMatter.build_ElectronicDistribution-Tuple{}"><code>LightMatter.build_ElectronicDistribution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_ElectronicDistribution(;Enabled = false, Electron_PhononCoupling = false, Ω=1.0, me = Constants.me)

Boltzmann clacluations are currently WIP.
Outer constructor function to assemble the ElectronicDistribution struct. Unit conversion is detected on all parameters.
Defaults allow any unneccessary parameters for users simulation to be ignored. Recommended to use Unitful Quantity
for me due to the unusual mass units in LightMatter.jl

# Arguments
- &#39;Enabled&#39;: Bool for enabling the full electronic distriubtion propagation
- &#39;Electron_PhononCoupling&#39;: Enables electronic distribution - phononic distribution bath coupling
- &#39;me&#39;: unit = eVm : Mass of conduction electron in LightMatter.jl mass units

# Returns
- The ElectronicDistribution struct with the users settings and parameters with any neccessary unit conversion.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L511-L526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_ElectronicTemperature-Tuple{}" href="#LightMatter.build_ElectronicTemperature-Tuple{}"><code>LightMatter.build_ElectronicTemperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_ElectronicTemperature(; Enabled = false, AthermalElectron_ElectronCoupling = false, Electron_PhononCoupling = false, Conductivity = false,
                           ElectronicHeatCapacity = :linear, ElectronPhononCouplingValue = :constant, γ = 1.0, κ = 1.0, λ = 1.0, ω = 1.0, g = 1.0)

Outer constructor function to assemble the ElectronicTemperature struct. Unit conversion is detected on all parameters.
Defaults allow any unneccessary parameters for users simulation to be ignored.

# Arguments
- &#39;Enabled&#39;: Bool for enabling an thermal electronic bath
- &#39;AthermalElectron_ElectronCoupling&#39;: Enables athermal electron - thermal electron coupling
- &#39;Electron_PhononCoupling&#39;: Enables electron bath - phonon bath coupling
- &#39;Conductivity&#39;: Bool for enabling thermnal electron diffusive transport
- &#39;ElectronicHeatCapacity&#39;: Method for calculating the electronic heat capacity, :linear or :nonlinear
- &#39;ElectronPhononCouplingValue&#39;: Method for calculating the electron phonon coupling value, either :constant or :variable
- &#39;γ&#39;: unit = eV/nm³/K²: Specific heat capacity of electronic bath for :linear ElectronicHeatCapacity
- &#39;κ&#39;: unit = eV/fs/nm/K: Thermal conductivity of electrons at room temperature
- &#39;λ&#39;: unit = unitless: Electron-phonon mass enhancement parameter
- &#39;ω&#39;: unit = eV^2: The second moment of the phonon spectrum
- &#39;g&#39;: unit = eV/fs/nm³/K: Constant value for the electron-phonon coupling if using :constant

# Returns
- The ElectronicTemperature struct with the users settings and parameters with any neccessary unit conversion.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L383-L405">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_Laser-Tuple{}" href="#LightMatter.build_Laser-Tuple{}"><code>LightMatter.build_Laser</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_laser(;envelope=:Gaussian, FWHM=10.0, ϕ=10.0, hv=5.0, Transport=:optical, ϵ=1.0, R=0.0, δb=1.0)

Outer constructor function to assemble the Laser struct. Can handle unit conversions if the user provides a 
unitful quantity to the laser. 
Defaults allow any unneccessary parameters for users simulation to be ignored.

# Arguments
- &#39;envelope&#39;: Symbol representing the shape of the envelope, :Gaussian, :HyperbolicSecant, :Lorentzian, :Rectangular
- &#39;FWHM&#39;: unit = fs:  Full-Width Half-Maximum of the laser pulse or half the duration of the Rectangular laser ± 0.0
- &#39;ϕ&#39;: unit = eV/nm²: The fluence of the laser 
- &#39;hv&#39;: unit = eV: The photon energy of the laser
- &#39;Transport&#39;: The method of spatial transport of the laser, :optical, :ballistic, :combined
- &#39;ϵ&#39;: unit = nm: The penetration depth of the material (1/α), for the :Optical &amp; :Combined transport
- &#39;R&#39;: unit = unitless:The reflectivity of the sample surface, leave at 0.0 if your provided fluence is the absorbed fluence
- &#39;δb&#39;: unit = nm:The ballistic length of electrons, for :ballistic &amp; :combined transport

# Returns
- The Laser struct with the user settings and neccessary values converted to the correct units</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L35-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_PhononicDistribution-Tuple{}" href="#LightMatter.build_PhononicDistribution-Tuple{}"><code>LightMatter.build_PhononicDistribution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_PhononicDistribution(;Enabled = false, Electron_PhononCoupling = false, Ω=1.0, me = Constants.me)

Boltzmann clacluations are currently WIP.
Outer constructor function to assemble the PhononicDistribution struct. Unit conversion is detected on all parameters.
Defaults allow any unneccessary parameters for users simulation to be ignored. Recommended to use Unitful Quantity
for me due to the unusual mass units in LightMatter.jl

# Arguments
- &#39;Enabled&#39;: Bool for enabling the full phononic distriubtion propagation
- &#39;Electron_PhononCoupling&#39;: Enables electronic distribution - phononic distribution bath coupling
- &#39;cs&#39;: unit = nm/fs : Speed of sound of longitudinal mode
= &#39;ED&#39;: unit = eV : Deybe energy of the material

# Returns
- The PhononicDistribution struct with the users settings and parameters with any neccessary unit conversion.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L555-L571">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_PhononicTemperature-Tuple{}" href="#LightMatter.build_PhononicTemperature-Tuple{}"><code>LightMatter.build_PhononicTemperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_PhononicTemperature(;Enabled = false, AthermalElectron_PhononCoupling = false, Electron_PhononCoupling = false, 
                           Conductivity = false, PhononicHeatCapacity = :linear, θ = 1.0, n = 1.0, Cph = 1.0, κ = 1.0)

Outer constructor function to assemble the PhononicTemperature struct. Unit conversion is detected on all parameters.
Defaults allow any unneccessary parameters for users simulation to be ignored.

# Arguments
- &#39;Enabled&#39;: Bool for enabling an thermal electronic bath
- &#39;AthermalElectron_PhononCoupling&#39;: Enables athermal electron - thermal electron coupling
- &#39;Electron_PhononCoupling&#39;: Enables electron bath - phonon bath coupling
- &#39;Conductivity&#39;: Bool for enabling thermal phonon diffusive transport
- &#39;PhononicHeatCapacity&#39;: Method for calculating the phononic heat capacity, :constant or :nonlinear
- &#39;θ&#39;: unit = K: Debye temperature of the material
- &#39;n&#39;: unit = atoms/nm³: Float64 of atoms per nm³
- &#39;Cph&#39;: unit = eV/nm³/K: Constant heat capacity for :constant
- &#39;κ&#39;: unit = eV/nm: Constant thermal conductivity of phonons

# Returns
- The PhononicTemperature struct with the users settings and parameters with any neccessary unit conversion.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L463-L483">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_Simulation-Tuple{}" href="#LightMatter.build_Simulation-Tuple{}"><code>LightMatter.build_Simulation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_Simulation(;densitymatrix::Union{DensityMatrix,NamedTuple,Nothing}=nothing, electronictemperature::Union{ElectronicTemperature,NamedTuple,Nothing}=nothing,
                       phononictemperature::Union{PhononicTemperature,NamedTuple,Nothing}=nothing, athermalelectrons::Union{AthermalElectrons,NamedTuple,Nothing}=nothing,
                       electronicdistribution::Union{ElectronicDistribution,NamedTuple,Nothing}=nothing, phononicdistribution::Union{PhononicDistribution,NamedTuple,Nothing}=nothing,
                       structure::Union{Structure,NamedTuple,Nothing}=nothing, laser::Union{Laser,NamedTuple,Nothing}=nothing)

Assembles the full Simulation struct from the requested components. Any systems not provided to the function are disabled by default.
The user can send either a completed Struct of the correct type or a NamedTuple with the correct key-word arguments to assemble the struct directly within the function
using the representative build_x function where x is the subsystem.

# Arguments
- &#39;densitymatrix&#39;: The DensityMatrix subsystem
- &#39;electronictemperature&#39;: The ElectronicTemperature subsystem
- &#39;phononictemperature&#39;: The PhononicTemperature subsystem
- &#39;athermalelectrons&#39;: The AthermalElectrons subsystem
- &#39;electronicdistribution&#39;: The ElectronicDistribution subsystem
- &#39;phononicdistribution&#39;: The PhononicDistribution subsystem
- &#39;structure&#39;: The Structure subsystem
- &#39;laser&#39;: The Laser subsystem

# Returns
- The PhononicTemperature struct with the users settings and parameters with any neccessary unit conversion.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L603-L625">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_Structure-Tuple{}" href="#LightMatter.build_Structure-Tuple{}"><code>LightMatter.build_Structure</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_Structure(; las::Laser=build_Laser(), Spatial_DOS::Bool = false, Elemental_System::Int = 1, dimension::Dimension = build_Dimension(),
                bulk_DOS::Union{String,Vector{String},Nothing} = nothing, DOS_folder::Union{String,Vector{String},Nothing} = nothing, 
                bulk_geometry::Union{String,Vector{String},Nothing} = nothing, slab_geometry::Union{String,Vector{String},Nothing} = nothing, 
                atomic_layer_tolerance::Union{Float64,Vector{Float64}} = 0.1, DOS::Union{spl,Vector{spl},Nothing} = nothing, 
                egrid::Union{Vector{Float64},Nothing} = nothing)

Outer constructor function to assemble the Structure struct. No unit conversion is performed.
All DOS files must be in the format |energy (eV), states (eV⁻¹Vᵤ⁻¹)|. Comment lines (#) are ignored
Defaults allow any unneccessary parameters for users simulation to be ignored.

# Arguments
- &#39;las&#39;: Laser struct, provide if not providing a pre-made energy grid
- &#39;Spatial_DOS&#39;: Bool for determening whether the DOS is spatially resolved or bulk
- &#39;Elemental_System&#39;: Float64 of different crystal systems in the structure
- &#39;dimension&#39;: Dimension struct, provide if not wanting a 0D calculation
- &#39;bulk_DOS&#39;: File location of the bulk DOS file
- &#39;DOS_folder&#39;: Location of a folder containing atom projected DOS. These must be in units of (eV⁻¹atom⁻¹) and be .dat files
- &#39;bulk_geometry&#39;: File location of the bulk DOS&#39; geometry.in file
- &#39;slab_geometry&#39;: File location of the geometry.in to create the atom projected DOS&#39; found in DOS_folder
- &#39;atomic_layer_tolerance&#39;: Minimum height spacing in Å for two atoms to be apart to be considered different layers
- &#39;DOS&#39;: A user made DOS or vector of DOS&#39; for the simulation if not wanting to use the DOS_initialization function. Will overwrite this function.
         Must be of the type DataInterpolations.LinearInterpolation or a vector of them. It is advised to have extrapolation enabled just in case. 
- &#39;egrid&#39;: A user made energy grid if not wanting to use build_egrid function. Will overwrite this function. Must be an evenly spaced grid that
           has length(egrid) % 4 == 1 for the numerical integration algorithm to work. 
- &#39;BandStructure&#39;: Contains splines of [k-&gt;E, E-&gt;k] for the evaluation of magnetotransport and group velocity

# Returns
- The Structure struct with the DOS and egrid assembled or provided by the user</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L172-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_egrid-Tuple{Any}" href="#LightMatter.build_egrid-Tuple{Any}"><code>LightMatter.build_egrid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_egrid(hv)

Builds an energy grid with spacing of 0.01 eV, limits of -2*hv to 2*hv and ensures that length(egrid) % 4 == 1

# Arguments
- &#39;hv&#39;: Photon energy of the laser

# Returns
- Evenly spaced energy grid that is suitable for the numerical integration algorithm and of sufficient accuracy/discretisation for accurate dynamics</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SimulationTypes.jl#L685-L695">source</a></section></article><h3 id="Athermal-Electron-Distribution"><a class="docs-heading-anchor" href="#Athermal-Electron-Distribution">Athermal Electron Distribution</a><a id="Athermal-Electron-Distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Athermal-Electron-Distribution" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.FE_initialization-Tuple{Union{String, Vector{String}}}" href="#LightMatter.FE_initialization-Tuple{Union{String, Vector{String}}}"><code>LightMatter.FE_initialization</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FE_initalization(bulk_DOS::Union{String, Vector{String}})

Initializes Fermi energy based on bulk density of states. This is defined as the difference between the bottom of the
valence band and 0.0. This is required for calculations such as the ballistic velocity or athermal electron lifetime due
to electronic interactions.

# Arguments
- `bulk_DOS`: (Array of) file path to bulk density-of-states

# Returns
- Fermi energy/energies for each DOS input.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L367-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.athem_electronelectroninteraction-Tuple{LightMatter.Simulation}" href="#LightMatter.athem_electronelectroninteraction-Tuple{LightMatter.Simulation}"><code>LightMatter.athem_electronelectroninteraction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">athem_electronelectroninteraction(sim::Simulation)

Returns an expression representing the electron-electron scattering term in the AthEM model.

# Arguments
- &#39;sim&#39;: settings of the desired simulation

# Returns
- Symbolic expression for relaxation or 0.0 if disabled.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L167-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.athem_electronelectronscattering!-NTuple{9, Any}" href="#LightMatter.athem_electronelectronscattering!-NTuple{9, Any}"><code>LightMatter.athem_electronelectronscattering!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">athem_electronelectronscattering(fdis::VectorTel::Float64,μ::Float64,sim::Simulation,fneq::Vector{Float64},DOS::spl,n::Float64,τee::Union{Float64,Vector{Float64}})

Calculates the electron-electron scattering contribution using a modified relaxation time approximation.

# Arguments
- &#39;Tel&#39;: Electronic temperature of the system
- &#39;μ&#39;: Chemical potential at the current temperature
- &#39;sim&#39;: Simulation settings and parameters
- &#39;fneq&#39;: Current non-equilibrium electron distribution
- &#39;DOS&#39;: Spline of the density-of-states
- &#39;n&#39;: The number of electrons in the thermal system
- &#39;τee&#39;: The athermal electron lifetime

# Returns
- Change in the non-equilibrium distribution due to scattering with a thermal electronic system</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L209-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.athem_electrongeneration!-NTuple{6, Any}" href="#LightMatter.athem_electrongeneration!-NTuple{6, Any}"><code>LightMatter.athem_electrongeneration!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">athem_electrongeneration!(tmp::Vector, egrid::Vector{Float64},DOS::spl,ftotspl::spl,hv::Float64,M::Union{Float64,Vector{Float64}})

Computes the shape of the distribution change due to electron generation.

# Arguments
- `tmp`: Temporary vector for in-place update
- `egrid`: Energy grid.
- `DOS`: Density of states spline.
- `ftotspl::spl`: Spline of the total distribution.
- `hv`: Photon energy.
- `M`: Matrix elements.

# Returns
- Change in distribution due to electron generation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L127-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.athem_electronphononinteraction-Tuple{LightMatter.Simulation}" href="#LightMatter.athem_electronphononinteraction-Tuple{LightMatter.Simulation}"><code>LightMatter.athem_electronphononinteraction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">athem_electronelectroninteraction(sim::Simulation)

Returns an expression representing the athermal electron-phonon scattering term in the AthEM model.

# Arguments
- &#39;sim&#39;: settings of the desired simulation

# Returns
- Symbolic expression for relaxation or 0.0 if disabled.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L280-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.athem_holegeneration!-NTuple{6, Any}" href="#LightMatter.athem_holegeneration!-NTuple{6, Any}"><code>LightMatter.athem_holegeneration!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">athem_holegeneration!(tmp::Vector, egrid::Vector{Float64},DOS::spl,ftotspl::spl,hv::Float64,M::Union{Float64,Vector{Float64}})

Computes the shape of the distribution change due to hole generation.

# Arguments
- `tmp`: Temporary vector for in-place update
- `egrid`: Energy grid.
- `DOS`: Density of states spline.
- `ftotspl::spl`: Spline of the total distribution.
- `hv`: Photon energy.
- `M`: Matrix elements.

# Returns
- Change in distribution due to hole generation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L105-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.athem_thermalelectronparticlechange-Tuple{LightMatter.Simulation}" href="#LightMatter.athem_thermalelectronparticlechange-Tuple{LightMatter.Simulation}"><code>LightMatter.athem_thermalelectronparticlechange</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">athem_thermalelectronparticlechange(sim::Simulation)

Returns an expression for the total thermal electronum number due to relaxation and optional conductivity.

# Arguments
- &#39;sim&#39;: settings of the desired simulation

# Returns
- Expr for the time dependence of the thermal electron number.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L320-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.athemdistribution_factory-Tuple{LightMatter.Simulation, Expr}" href="#LightMatter.athemdistribution_factory-Tuple{LightMatter.Simulation, Expr}"><code>LightMatter.athemdistribution_factory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">athemdistribution_factory(sim, laser_expr)

Constructs the time evolution of the non-equilibrium distribution in the AthEM model
Find out more at https://arxiv.org/abs/2503.09479

# Arguments
- `sim`::Simulation
       Simulation struct containing physical and model parameters.
- `laser_expr`::Expr
              Expression representing the laser excitation term.

# Returns
- The total expression for the evolution of the athermal electron distribution, combining excitation and scattering terms.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L2-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.athemexcitation!-Tuple{Any, Any, Any, Any, Any, Float64, Any}" href="#LightMatter.athemexcitation!-Tuple{Any, Any, Any, Any, Any, Float64, Any}"><code>LightMatter.athemexcitation!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">athemexcitation!(Δfneqe::DiffCache, Δfneqh::DiffCache, ftot::Vector{Float64}, egrid::Vector{Float64}, DOS::spl, hv::Float64, M::Union{Float64,Vector{Float64}})

Computes the net non-equilibrium excitation using Fermi&#39;s Golden Rule.

# Arguments
- &#39;Δfneqe&#39;: A pre-initialized vector to reduce allocations. Can be DiffCache or Vector. 
            This vector contains the final result
- &#39;Δfneqh&#39;: A pre-initialized vector to reduce allocations. Can be DiffCache or Vector.
- `ftot`: Total distribution (f_eq + f_neq).
- `egrid`: Energy grid.
- `DOS`: Density of states spline.
- `hv`: Photon energy.
- `M`: Matrix elements.

# Returns
- In-place normalized change in particle distribution shape. Multiply by inputted laser energy at time t to get 
  full excitation shape change</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L62-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.athemexcitation_matrixelements-Tuple{LightMatter.Simulation}" href="#LightMatter.athemexcitation_matrixelements-Tuple{LightMatter.Simulation}"><code>LightMatter.athemexcitation_matrixelements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">athemexcitation_matrixelements(sim::Simulation)

Returns the symbolic matrix element expression for photo-excitation.
Currently implemented:
- :unity : No specified matrix elements - Returns 1.0

# Arguments
- &#39;sim&#39;: settings of the desired simulation

# Returns
- Matrix element expression.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L149-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_athemdistribution-Tuple{LightMatter.Simulation, Expr, Union{Float64, Expr}, Union{Float64, Expr}}" href="#LightMatter.build_athemdistribution-Tuple{LightMatter.Simulation, Expr, Union{Float64, Expr}, Union{Float64, Expr}}"><code>LightMatter.build_athemdistribution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_athemdistribution(sim, athemexcite, Elecelec, Elecphon)

Combines excitation and scattering contributions into a single broadcasted sum expression in the AthEM model

# Arguments
- `sim`::Simulation
       The simulation object.
- `athemexcite`::Expr
               Expression for athermal excitation.
- `Elecelec`::Union{Expr, Float64}
            Electron-electron scattering Expr or 0.0 if disabled
- `Elecphon`::Union{Expr, Float64}
            Electron-phonon scattering Expr or 0.0 if disabled

# Returns
- A broadcasted summation of all interaction terms.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L37-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.electron_distribution_transport!-Tuple{Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Real}" href="#LightMatter.electron_distribution_transport!-Tuple{Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Real}"><code>LightMatter.electron_distribution_transport!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">electron_distribution_transport!(v_g::Vector{Float64},f::AbstractArray{Float64},Δf::AbstractArray{Float64},dz::Float64)

Computes ballistic transport of an electronic distribution using second-order finite differences via a kinetic like model.
Uses forward(reverse) difference for the boundaries. 

# Arguments
- `v_g`: Group velocity vector or vector of vectors(spatially-resolved DOS)
- `f`: Distribution function.
- `Δf`: Output array to store result.
- `dz`: Spatial resolution.

# Returns
- In-place change to Δf</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L334-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.electron_relaxationtime-Tuple{LightMatter.Simulation}" href="#LightMatter.electron_relaxationtime-Tuple{LightMatter.Simulation}"><code>LightMatter.electron_relaxationtime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">electron_relaxationtime(sim::Simulation)
Returns the requested expression for the electronic relaxation time. 
Currently implemented: 
- :constant : A constant time defined by sim.athermalelectrons.τ
- :FLT : Fermi Liquid lifetime defined in https://arxiv.org/abs/2503.09479

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Expression for the athermal electron lifetime due to electron-electron interactions.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L189-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.find_relaxeddistribution!-NTuple{5, Any}" href="#LightMatter.find_relaxeddistribution!-NTuple{5, Any}"><code>LightMatter.find_relaxeddistribution!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_relaxeddistribution(egrid::Vector{Float64},goal::Float64,n::Float64,DOS::spl,kB::Float64)

Solves for a Fermi distribution with the same internal energy as a given target.

# Arguments
- &#39;egrid&#39;: Energy grid distributions are solved on
- &#39;goal&#39;: The internal energy of the total electronic system
- &#39;n&#39;: Float64 of electrons in the thermal system
- &#39;DOS&#39;: Spline of the density-of-states

# Returns
- Fermi-Dirac distribution with same internal energy as the goal.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L236-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.find_temperatureandμ!-Tuple{Any, Any, Any}" href="#LightMatter.find_temperatureandμ!-Tuple{Any, Any, Any}"><code>LightMatter.find_temperatureandμ!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_temperatureandμ(Tel::Float64,n::Float64,DOS::spl,egrid::Vector{Float64})

Given a temperature guess, computes chemical potential and internal energy.

# Arguments
- &#39;Tel&#39;: Guessed electronic temperature to match the goal
- &#39;n&#39;: Float64 of electrons in the thermal system
- &#39;egrid&#39;: Energy grid distributions are solved on
- &#39;DOS&#39;: Spline of the density-of-states

# Returns
- Internal energy of the current temperature guess.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L257-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.phonon_relaxationtime-Tuple{LightMatter.Simulation}" href="#LightMatter.phonon_relaxationtime-Tuple{LightMatter.Simulation}"><code>LightMatter.phonon_relaxationtime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phonon_relaxationtime(sim::Simulation)

Determines the requested expression for the electron-phonon relaxation time. 
Currently implemented:
- :constant : a constant lifetime given by simulation.athermalelectrons.τep
- :quasi : quasiparticle relaxation time defined in E.Carpene, Phys. Rev. B., 2006, 74, 024301.

# Arguments
- &#39;sim&#39;: settings of the desired simulation

# Returns
- Expression for the athermal electron lifetime due to phonon interactions.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AthermalElectrons.jl#L299-L312">source</a></section></article><h3 id="Density-Matrix"><a class="docs-heading-anchor" href="#Density-Matrix">Density Matrix</a><a id="Density-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Density-Matrix" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_dm-Tuple{Any, Any}" href="#LightMatter.build_dm-Tuple{Any, Any}"><code>LightMatter.build_dm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_dm(N::Int, occ::Vector{Float64})

Builds a density matrix of NxN states with diagonal occupations occ

# Arguments
- &#39;N&#39;: Number of states
- &#39;occ&#39;: Initial occupations of the density matrix 

# Returns
- An assembled density matrix with diagonal given by occ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DensityMatrix.jl#L18-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.construct_dipolevonNeumann-Tuple{LightMatter.Simulation}" href="#LightMatter.construct_dipolevonNeumann-Tuple{LightMatter.Simulation}"><code>LightMatter.construct_dipolevonNeumann</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">discretize_DOS(sim::Simulation)

Constructs an expression for the propagation of a Hamiltonian&#39;s reaction to light
in the dipole approximation. It takes the dipole matrix from sim.densitymatrix.DipoleMatrix

# Arguments
- &#39;sim&#39;: Settings of the simulation containing the dipole matrix and electric fields 

# Returns
- Expression for the propagation of a density matrix under illumination in the dipole approximation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DensityMatrix.jl#L116-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.discretize_DOS-Tuple{Any, Any, Any}" href="#LightMatter.discretize_DOS-Tuple{Any, Any, Any}"><code>LightMatter.discretize_DOS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">discretize_DOS(dos_file::String, no_states::Int, egrid::Vector{Float64})

Discretizes a DOS and creates a vector of repeating energy states of length no_states.
The number of these repeats should mimic the shape of the original DOS. The discretization is 
only performed along the vector given by egrid. 

# Arguments
- &#39;dos_file&#39;: File path to DOS
- &#39;no_states&#39;: Approximate length of the final vector (there may be slight differences in the final result)
- &#39;egrid&#39;: Vector of energy values to discretize the DOS onto 

# Returns
- An approximation of a DOS to use as the diagonal of a Hamiltonian</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DensityMatrix.jl#L63-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.thermal_bath_densitymatrix-Tuple{Any, Any, Any}" href="#LightMatter.thermal_bath_densitymatrix-Tuple{Any, Any, Any}"><code>LightMatter.thermal_bath_densitymatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">thermal_bath_densitymatrix(H::Matrix{Float64}, β::Float64, ne::Int)

Builds a thermal density matrix assuming Fermi-Dirac statistics 

# Arguments
- &#39;H&#39;: Hamiltonian of the system, no external forces should be included here
- &#39;Β&#39;: kB*T in the same units as the Hamiltonian
- &#39;ne&#39;: The total number of electrons the density matrix represents

# Returns
- An assembled density matrix with a thermal occupation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DensityMatrix.jl#L45-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.total_DOS_states-Tuple{Any, Any}" href="#LightMatter.total_DOS_states-Tuple{Any, Any}"><code>LightMatter.total_DOS_states</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">discretize_DOS(DOS::spl, egrid::Vector{Float64})

Calculates the total number of states within the range of the egrid of the DOS
provided by dos_file in discretize_DOS.

# Arguments
- &#39;DOS&#39;: Spline of the DOS generated from dos_file
- &#39;egrid&#39;: Vector of energy values to discretize the DOS onto 

# Returns
- Total number of states in the energy window (egrid) of the DOS</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DensityMatrix.jl#L98-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.vonNeumann-Tuple{Any, Any, Any}" href="#LightMatter.vonNeumann-Tuple{Any, Any, Any}"><code>LightMatter.vonNeumann</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vonNeumann(dρ::Matrix{Float64},ρ::Matrix{Float64},H::Matrix{Float64})

Equation of motion for a density matrix

# Arguments
- &#39;dρ&#39;: In-place derivative of the density matrix
- &#39;ρ&#39;: Density matrix of the system
- &#39;H&#39;: Hamiltonian matrix of the system

# Returns
- In-place function calculating dρ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DensityMatrix.jl#L1-L13">source</a></section></article><h3 id="Total-Electronic-Distribution"><a class="docs-heading-anchor" href="#Total-Electronic-Distribution">Total Electronic Distribution</a><a id="Total-Electronic-Distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Total-Electronic-Distribution" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.FermiDirac-Tuple{Any, Any, Any}" href="#LightMatter.FermiDirac-Tuple{Any, Any, Any}"><code>LightMatter.FermiDirac</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FermiDirac(Tel::Float64, μ::Float64, E::Union{Vector{Float64},Float64}) 

Returns the thermal occupation of electrons at a given temperature, chemical potential and energy.
If a vector of energies is given then it will return the distribution across that range.

# Arguments
- &#39;Tel&#39;: Thermal electronic temperature
- &#39;μ&#39;: Chemical Potential
- &#39;E&#39;: Energy value or range

# Returns
- Value or vector of the Fermi-Dirac distribution</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicDistribution.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.dFDdE-Tuple{Any, Any, Any}" href="#LightMatter.dFDdE-Tuple{Any, Any, Any}"><code>LightMatter.dFDdE</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dFDdE(Tel::Float64, μ::Float64, E::Union{Vector{Float64},Float64})

Returns the change in the Fermi distribution with respect to energy at the given energy value or range.

# Arguments
- &#39;Tel&#39;: Thermal electronic temperature
- &#39;μ&#39;: Chemical Potential
- &#39;E&#39;: Energy value or range

# Returns
- Value or vector of the partial derivative of the Fermi distribution with respect to energy</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicDistribution.jl#L25-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.dFDdT-Tuple{Any, Any, Any}" href="#LightMatter.dFDdT-Tuple{Any, Any, Any}"><code>LightMatter.dFDdT</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dFDdT(Tel::Float64, μ::Float64, E::Union{Vector{Float64},Float64})

Returns the change in the Fermi distribution with respect to temperature at the given energy value or range.

# Arguments
- &#39;Tel&#39;: Thermal electronic temperature
- &#39;μ&#39;: Chemical Potential
- &#39;E&#39;: Energy value or range

# Returns
- Value or vector of the partial derivative of the Fermi distribution with respect to temperature</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicDistribution.jl#L42-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.dFDdμ-Tuple{Any, Any, Any}" href="#LightMatter.dFDdμ-Tuple{Any, Any, Any}"><code>LightMatter.dFDdμ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dFDdμ(Tel::Float64, μ::Float64, E::Union{Vector{Float64},Float64})

Returns the change in the Fermi distribution with respect to chemical potential at the given energy value or range.

# Arguments
- &#39;Tel&#39;: Thermal electronic temperature
- &#39;μ&#39;: Chemical Potential
- &#39;E&#39;: Energy value or range

# Returns
- Value or vector of the partial derivative of the Fermi distribution with respect to chemical potential</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicDistribution.jl#L58-L70">source</a></section></article><h3 id="Thermal-Electron-Bath"><a class="docs-heading-anchor" href="#Thermal-Electron-Bath">Thermal Electron Bath</a><a id="Thermal-Electron-Bath-1"></a><a class="docs-heading-anchor-permalink" href="#Thermal-Electron-Bath" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.athem_electempenergychange-Tuple{LightMatter.Simulation}" href="#LightMatter.athem_electempenergychange-Tuple{LightMatter.Simulation}"><code>LightMatter.athem_electempenergychange</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">athem_electempenergychange(sim::Simulation)

Builds an expression for the change in internal energy of an AthEM electronic bath

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Expression for the change of internal energy of an AthEM electronic bath</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicTemperature.jl#L160-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_athemelectron-Tuple{Expr}" href="#LightMatter.build_athemelectron-Tuple{Expr}"><code>LightMatter.build_athemelectron</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_athemelectron(Δu::Expr)

Builds the differential equation (expression) for an AthEM thermal bath. The difference to the TTM
is due to accounting for the changing particle number

# Arguments
- &#39;Δu&#39;: Expression for the change in internal energy of the electronic bath

# Returns
- Expression for the time evolution of a, AthEM electronic temperature</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicTemperature.jl#L143-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_electronTTM-Tuple{LightMatter.Simulation, Expr, Expr, Expr}" href="#LightMatter.build_electronTTM-Tuple{LightMatter.Simulation, Expr, Expr, Expr}"><code>LightMatter.build_electronTTM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_electronTTM(sim::Simulation, Source::Expr, ElecPhon::Expr, HeatCapacity::Expr)

Builds the differential equation (expression) for a Two-Temperature like system.

# Arguments
- &#39;sim&#39;: Simulation settings and parameters
- &#39;Source&#39;: Expression for the incoming energy source (typically a laser)
- &#39;ElecPhon&#39;: Expression for the electron-phonon coupling
- &#39;HeatCapacity&#39;: Expression for calculating the heat capacity

# Returns
- Expression for the time evolution of a two-temperature model electronic temperature</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicTemperature.jl#L23-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.depthderivative!-Tuple{Any, Any, Any}" href="#LightMatter.depthderivative!-Tuple{Any, Any, Any}"><code>LightMatter.depthderivative!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">depthderivative!(vec::Vector{Float64}, dz::Float64, Diff::Vector{Float64})

Calculates a 2nd order finite difference method of a vector along a grid with spacing dz.
Uses central difference in the middle and forward(reverse) difference at the top(end) of the vector

# Arguments
- &#39;vec&#39;: Vector the finite difference is being performed over
- &#39;dz&#39;: z-grid spacing
- &#39;Diff&#39;: Vector to store the finite difference result

# Returns
- Updates the diff vector with the finite difference result</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicTemperature.jl#L230-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.elec_energychange-Tuple{Any, Any, Any}" href="#LightMatter.elec_energychange-Tuple{Any, Any, Any}"><code>LightMatter.elec_energychange</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elec_energychange(egrid::Vector{Float64}, relax_dis::Vector{Float64}, DOS::spl)

Calculates the energy change of the thermal bath due to non-equilibrium-equilibrium
electron scattering.

# Arguments
- &#39;egrid: Energy grid the simulation is solved over
- &#39;relax_dis&#39;: The change in distribution due to the electron-electron scattering
- &#39;DOS&#39;: Density-of-states of the system

# Returns
- The change in the internal energy of the thermal system due to e-e scattering</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicTemperature.jl#L182-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.electronphonon_coupling-Tuple{LightMatter.Simulation}" href="#LightMatter.electronphonon_coupling-Tuple{LightMatter.Simulation}"><code>LightMatter.electronphonon_coupling</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">electronphonon_coupling(sim::Simulation)

Determines the expression for the coupling between an electronic and phononic thermal bath.
Currently implemented:
- :variable : Calculates the electron-phonon coupling parameter from the density-of-states of the system
- :constant : Uses a constant value for the electron-phonon coupling parameter (g)

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Expression for the electron-phonon thermal bath energy transfer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicTemperature.jl#L89-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.electrontemperature_conductivity!-NTuple{5, Any}" href="#LightMatter.electrontemperature_conductivity!-NTuple{5, Any}"><code>LightMatter.electrontemperature_conductivity!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">electrontemperature_conductivity!(Tel::Vector{Float64}, κ::Union{Float64,Vector{Float64}}, dz::Float64, Tph::Vector{Float64}, cond::Vector{Float64})

Calculates the change in temperature due to diffusive transport of energy through the system. Uses the boundary conditions of
setting dTel / dz to 0.0.

# Arguments
- &#39;Tel&#39;: Temperature of the electronic bath
- &#39;κ&#39;: Electronic thermal conductivity at room temperature
- &#39;dz&#39;: z-grid spacing
- &#39;Tph&#39;: Temperature of the phonon bath
- &#39;cond&#39;: Vector to store the change in electronic temperature

# Returns
- Updates the cond vector with the change in electronic temperature at each grid point</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicTemperature.jl#L199-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.electrontemperature_factory-Tuple{LightMatter.Simulation, Expr}" href="#LightMatter.electrontemperature_factory-Tuple{LightMatter.Simulation, Expr}"><code>LightMatter.electrontemperature_factory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">electrontemperature_factory(sim::Simulation, laser::Expr)

Assembles expresssion for how the electronic temperature should be propgated through time.

# Arguments
- &#39;sim&#39;: Simulation settings and parameters
- &#39;laser&#39;: Expression for laser energy as a funciton of time

# Returns
- Expression for the time-propagation of the electronic temperature subsystem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicTemperature.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.electrontemperature_heatcapacity-Tuple{LightMatter.Simulation}" href="#LightMatter.electrontemperature_heatcapacity-Tuple{LightMatter.Simulation}"><code>LightMatter.electrontemperature_heatcapacity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">electrontemperature_heatcapacity(sim::Simulation)

Determines the expression for the electronic temperature&#39;s heat capacity.
Currently implemented:
- :linear : Specific heat of electrons(γ) multiplied by the current temperature
- :nonlinear : Calculated from the density-of-states of the system

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Expression for the electronic temperature&#39;s heat capacity</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicTemperature.jl#L44-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.nonlinear_electronheatcapacity-Tuple{Any, Any, Any}" href="#LightMatter.nonlinear_electronheatcapacity-Tuple{Any, Any, Any}"><code>LightMatter.nonlinear_electronheatcapacity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nonlinear_electronheatcapacity(Tel::Float64, μ::Float64, DOS::spl, egrid::Vector{Float64})

Calculates non-linear electronic bath heat capacity. A more accurate method than the
linear form.

# Arguments
- &#39;Tel&#39;: Temperature of the electronic bath
- &#39;μ&#39;: Chemical potential of the electronic bath
- &#39;DOS&#39;: Density-of-states of the system
- &#39;egrid&#39;: Energy grid the simulation is solved over

# Returns
- The current heat capacity of the electronic thermal bath</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicTemperature.jl#L67-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.variable_electronphononcoupling-NTuple{6, Any}" href="#LightMatter.variable_electronphononcoupling-NTuple{6, Any}"><code>LightMatter.variable_electronphononcoupling</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variable_electronphononcoupling(λ::Float64, ω::Float64, DOS::spl, Tel::Float64, μ::Float64, Tph::Float64, egrid::Vector{Float64})

Calculates the non-linear electron phonon coupling parameter and subsequent energy flow from the density-of-states
of the system. More accurate than a constant value. 
The expression can be found in Z. Lin, L. V. Zhigilei and V. Celli, Phys. Rev. B, 2008, 77, 075133.

# Arguments
- &#39;λ&#39;: Electron-phonon mass enhancement parameter
- &#39;ω&#39;: Second moment of the phonon spectrum
- &#39;DOS&#39;: Density-of-states of the system
- &#39;Tel&#39;: Temperature of the electronic bath
- &#39;μ&#39;: Chemical potential of the electronic bath
- &#39;Tph&#39;: Temperature of the phonon bath
- &#39;egrid&#39;: Energy grid the simulation is solved over

# Returns
- Energy flow between an electronic and phononic bath with a calculate g parameter</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/ElectronicTemperature.jl#L114-L132">source</a></section></article><h3 id="Lasers"><a class="docs-heading-anchor" href="#Lasers">Lasers</a><a id="Lasers-1"></a><a class="docs-heading-anchor-permalink" href="#Lasers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.E_magnitude-Tuple{Any, Any}" href="#LightMatter.E_magnitude-Tuple{Any, Any}"><code>LightMatter.E_magnitude</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">E_magnitude(las_field::Vector{Expr}, ext_field::Vector{Expr})

# Arguments
- &#39;las_field&#39;: Electric field vector from the laser
- &#39;ext_field&#39;: Electric field vector from external sources

# Returns
- Expression for the total magntitude of electric fields</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/Lasers.jl#L176-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.get_laser_fields-Tuple{Any}" href="#LightMatter.get_laser_fields-Tuple{Any}"><code>LightMatter.get_laser_fields</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_laser_fields(las::Laser)

Returns an expression for the electric field induced by the laser
Currently implemented:
- :Gaussian
- :Rectangular

# Arguments
- &#39;las&#39;: Laser settings 

# Returns
- Expression for the electric field of the laser</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/Lasers.jl#L126-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.laser_factory-Tuple{LightMatter.Simulation}" href="#LightMatter.laser_factory-Tuple{LightMatter.Simulation}"><code>LightMatter.laser_factory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">laser_factory(sim::Simulation)

Assembles the user desired laser expression

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Expression for the power of the laser as a function of time and depth</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/Lasers.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.photon_energytofrequency-Tuple{Any}" href="#LightMatter.photon_energytofrequency-Tuple{Any}"><code>LightMatter.photon_energytofrequency</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">photon_energytofrequency(hv::Real)

# Arguments
- &#39;hv&#39;: Photon energy in eV

# Returns
- Photon frequency in 1 / fs</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/Lasers.jl#L164-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.spatial_laser-Tuple{LightMatter.Simulation}" href="#LightMatter.spatial_laser-Tuple{LightMatter.Simulation}"><code>LightMatter.spatial_laser</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spatial_laser(sim::Simulation)

Assembles the expression for the laser penetration depth. Currently only works in the z-axis

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Expression for the spatial shape of the laser</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/Lasers.jl#L47-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.spatial_xy_laser-Tuple{LightMatter.Simulation}" href="#LightMatter.spatial_xy_laser-Tuple{LightMatter.Simulation}"><code>LightMatter.spatial_xy_laser</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WIP: spatial_xy_laser(sim::Simulation)

Defines how the laser energy changes with distance from the spot centre. Do not use as simulations
aren&#39;t constructed for more than 1D.

Currently implemented:
- :Cylindrical : Circular shaped sample
- :Cubic : Cubic shaped sample

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Expression for the spatial shape of the laser in the xy plane</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/Lasers.jl#L101-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.spatial_z_laser-Tuple{LightMatter.Simulation}" href="#LightMatter.spatial_z_laser-Tuple{LightMatter.Simulation}"><code>LightMatter.spatial_z_laser</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spatial_z_laser(sim::Simulation)

Defines how the laser energy changes with depth into the sample
Currently implemented:
- :ballistic : Ballistic depth of electrons defines spatial change, controlled by δb
- :optical : Absorbtion depth of the laser controls the spatial change, controlled by ϵ (1/α)
- :combined : Both ballistic and optical parameters enabled, sums the two effects together

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Expression for the spatial shape of the laser</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/Lasers.jl#L62-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.temporal_laser-Tuple{Laser}" href="#LightMatter.temporal_laser-Tuple{Laser}"><code>LightMatter.temporal_laser</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">temporal_laser(las::Laser)

Assembles the expression for the user desired temporal shape of the laser
Currently implemented:
- :Gaussian : Gaussian laser shape
- :Lorentzian : Lorentzian laser shape
- :HyperbolicSecant : Hyperbolic secant laser shape
- :Rectangular : Constant illumination style method. The laser is on for 2*FWHM at either side of 0.0 fs

# Arguments
- &#39;las&#39;: Settings and parameters of the laser

# Returns
- Expression for the temporal shape of the laser</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/Lasers.jl#L18-L33">source</a></section></article><h3 id="Phononic-Distribution"><a class="docs-heading-anchor" href="#Phononic-Distribution">Phononic Distribution</a><a id="Phononic-Distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Phononic-Distribution" title="Permalink"></a></h3><h3 id="Thermal-Phonon-Bath"><a class="docs-heading-anchor" href="#Thermal-Phonon-Bath">Thermal Phonon Bath</a><a id="Thermal-Phonon-Bath-1"></a><a class="docs-heading-anchor-permalink" href="#Thermal-Phonon-Bath" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_phonontemperature-Tuple{LightMatter.Simulation, Union{Float64, Expr}, Expr, Expr}" href="#LightMatter.build_phonontemperature-Tuple{LightMatter.Simulation, Union{Float64, Expr}, Expr, Expr}"><code>LightMatter.build_phonontemperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_phonontemperature(sim::Simulation, Source::Expr, ElecPhon::Expr, HeatCapacity::Expr)

Builds the differential equation (expression) for the phonon bath

# Arguments
- &#39;sim&#39;: Simulation settings and parameters
- &#39;Source&#39;: Expression for energy input from athermal electrons
- &#39;ElecPhon&#39;: Expression for the thermal electron-phonon coupling
- &#39;HeatCapacity&#39;: Expression for calculating the heat capacity

# Returns
- Expression for the time evolution of a phnonic thermal bath</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PhononicTemperature.jl#L17-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.neqelectron_phonontransfer-NTuple{4, Any}" href="#LightMatter.neqelectron_phonontransfer-NTuple{4, Any}"><code>LightMatter.neqelectron_phonontransfer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neqelectron_phonontransfer(fneq::Vector{Float64}, egrid::Vector{Float64}, τep::Float64, DOS::spl)

Calculates energy input into the phonon bath due to non-equilibrium electron-phonon scattering

# Arguments
- &#39;fneq&#39;: Non-equilibrium electron distribution
- &#39;egrid&#39;: Energy grid the distributions are solved on
- &#39;τep&#39;: Lifetime of athermal electrons due to electron-phonon scattering
- &#39;DOS&#39;: Density-of-states of the system

# Returns
- Value of the change in the phonon internal energy</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PhononicTemperature.jl#L100-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.phonontemperature_conductivity!-NTuple{4, Any}" href="#LightMatter.phonontemperature_conductivity!-NTuple{4, Any}"><code>LightMatter.phonontemperature_conductivity!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phonontemperature_conductivity!(Tph::Vector{Float64}, κ::Union{Float64,Vector{Float64}}, dz::Float64, cond::Vector{Float64})

Calculates thermal phonon conductivity due to diffusive transport

# Arguments
- &#39;Tph&#39;: Phonon bath temperature
- &#39;κ&#39;: Phonon thermal conductivity (assumed constant)
- &#39;dz&#39;: Spacing of the spatial grid
- &#39;cond&#39;: Vector to store the temperature change

# Returns
- Updates cond with the change in temperature at each z-grid point</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PhononicTemperature.jl#L117-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.phonontemperature_factory-Tuple{LightMatter.Simulation}" href="#LightMatter.phonontemperature_factory-Tuple{LightMatter.Simulation}"><code>LightMatter.phonontemperature_factory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phonontemperature_factory(sim::Simulation)

Assembles expresssion for how the phononic temperature should be propgated through time.

# Arguments
- &#39;sim&#39;: Simulation settings and parameters
# Returns
- Expression for the time-propagation of the phononic temperature subsystem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PhononicTemperature.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.phonontemperature_heatcapacity-Tuple{LightMatter.Simulation}" href="#LightMatter.phonontemperature_heatcapacity-Tuple{LightMatter.Simulation}"><code>LightMatter.phonontemperature_heatcapacity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phonontemperature_heatcapacity(sim::Simulation)

Determines the expression for the phononic temperature&#39;s heat capacity.
Currently implemented:
- :constant : Constant phonon heat capacity (Cph)
- :variable : Calculated from Simpson&#39;s rule

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Expression for the phononic temperature&#39;s heat capacity</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PhononicTemperature.jl#L38-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.phonontemperature_source-Tuple{LightMatter.Simulation}" href="#LightMatter.phonontemperature_source-Tuple{LightMatter.Simulation}"><code>LightMatter.phonontemperature_source</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phonontemperature_source(sim::Simulation)

Determines the expresision of any additional source terms into the phonon bath. Currently this
is just athermal electron-phonon coupling
Currently implemented:

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Expression for any source term into the phonon bath</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PhononicTemperature.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.variable_phononheatcapacity-Tuple{Any, Any, Any}" href="#LightMatter.variable_phononheatcapacity-Tuple{Any, Any, Any}"><code>LightMatter.variable_phononheatcapacity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variable_phononheatcapacity(Tph::Float64, n::Float64, θ::Float64)

Calculates non-linear phononic bath heat capacity. A more accurate method than the
constant form.

# Arguments
- &#39;Tph&#39;: Temperature of the phononic bath
- &#39;n&#39;: Float64 of atoms per nm³
- &#39;θ&#39;: Debye temperature of the system

# Returns
- The current heat capacity of the phononic thermal bath</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PhononicTemperature.jl#L59-L72">source</a></section></article><h3 id="Property-Calculation"><a class="docs-heading-anchor" href="#Property-Calculation">Property Calculation</a><a id="Property-Calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Property-Calculation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.Bode_rule-Tuple{Any, Any}" href="#LightMatter.Bode_rule-Tuple{Any, Any}"><code>LightMatter.Bode_rule</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bode_rule(y::Vector{Float64}, x::Vector{Float64})

Performs numerical integration on a grid using the higher order Boole&#39;s method.
Will integrate from end to end of the x vector

# Arguments
- &#39;y&#39;: The spectrum on a grid to be integrated
- &#39;x&#39;: The grid the spectrum is on w

# Returns
- The integration value across the range</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PropertyFunctions.jl#L143-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.c_T-NTuple{4, Any}" href="#LightMatter.c_T-NTuple{4, Any}"><code>LightMatter.c_T</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">c_T(μ::Float64, Tel::Float64, DOS::spl, egrid::Vector{Float64})

Calculates the change in internal energy of a Fermi Dirac distribution with respect to temperature

# Arguments
- &#39;μ&#39;: Electronic distribution
- &#39;Tel&#39;: The electronic bath temperature
- &#39;DOS&#39;: Density-of-states of the system
- &#39;egrid&#39;: Energy grid the simulation is solved over

# Returns
- The value of dU/dT</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PropertyFunctions.jl#L107-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.c_μ-NTuple{4, Any}" href="#LightMatter.c_μ-NTuple{4, Any}"><code>LightMatter.c_μ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">c_μ(μ::Float64, Tel::Float64, DOS::spl, egrid::Vector{Float64})

Calculates the change in internal energy of a Fermi Dirac distribution with respect to chemical potential

# Arguments
- &#39;μ&#39;: Electronic distribution
- &#39;Tel&#39;: The electronic bath temperature
- &#39;DOS&#39;: Density-of-states of the system
- &#39;egrid&#39;: Energy grid the simulation is solved over

# Returns
- The value of dU/dμ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PropertyFunctions.jl#L125-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.find_chemicalpotential-NTuple{4, Any}" href="#LightMatter.find_chemicalpotential-NTuple{4, Any}"><code>LightMatter.find_chemicalpotential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_chemicalpotential(no_part::Float64, Tel::Float64, DOS::spl, egrid::Vector{Float64})

Determines the chemical potential at the current temperature

# Arguments
- &#39;no_part&#39;: Float64 of particles in the thermal electronic system
- &#39;Tel&#39;: Temperature of the electronic bath
- &#39;DOS&#39;: Density-of-states of the system
- &#39;egrid&#39;: Energy grid the simulation is solved over

# Returns
- The value of the chemical potential</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PropertyFunctions.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.get_internalenergy-Tuple{Any, Any, Any}" href="#LightMatter.get_internalenergy-Tuple{Any, Any, Any}"><code>LightMatter.get_internalenergy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_internalenergy(Dis::Vector{Float64}, DOS::spl, egrid::Vector{Float64})

Calculates the internal energy of the given electronic distribution

# Arguments
- &#39;Dis&#39;: Electronic distribution
- &#39;DOS&#39;: Density-of-states of the system
- &#39;egrid&#39;: Energy grid the simulation is solved over

# Returns
- The internal energy of the given distribution</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PropertyFunctions.jl#L90-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.get_noparticles-Tuple{Any, Any, Any}" href="#LightMatter.get_noparticles-Tuple{Any, Any, Any}"><code>LightMatter.get_noparticles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_noparticles(Dis::Vector{Float64}, DOS::spl, egrid::Vector{Float64})

Calculates number of electrons in the given distribution

# Arguments
- &#39;Dis&#39;: Electronic distribution
- &#39;DOS&#39;: Density-of-states of the system
- &#39;egrid&#39;: Energy grid the simulation is solved over

# Returns
- The number of electrons</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PropertyFunctions.jl#L37-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.get_thermalparticles-NTuple{4, Any}" href="#LightMatter.get_thermalparticles-NTuple{4, Any}"><code>LightMatter.get_thermalparticles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_thermalparticles(μ::Float64, Tel::Float64, DOS::spl, egrid::Vector{Float64})

Calculates number of electrons assuming a Fermi Dirac distribution

# Arguments
- &#39;μ&#39;: Chemical potential
- &#39;Tel&#39;: Temperature of the electronic bath
- &#39;DOS&#39;: Density-of-states of the system
- &#39;egrid&#39;: Energy grid the simulation is solved over

# Returns
- The number of electrons</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PropertyFunctions.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.p_T-NTuple{4, Any}" href="#LightMatter.p_T-NTuple{4, Any}"><code>LightMatter.p_T</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">p_T(μ::Float64, Tel::Float64, DOS::spl, egrid::Vector{Float64})

Calculates the change in the number of particles of a Fermi Dirac distribution with respect to temperature

# Arguments
- &#39;μ&#39;: Electronic distribution
- &#39;Tel&#39;: The electronic bath temperature
- &#39;DOS&#39;: Density-of-states of the system
- &#39;egrid&#39;: Energy grid the simulation is solved over

# Returns
- The value of dn/dT</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PropertyFunctions.jl#L54-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.p_μ-NTuple{4, Any}" href="#LightMatter.p_μ-NTuple{4, Any}"><code>LightMatter.p_μ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">p_μ(μ::Float64, Tel::Float64, DOS::spl, egrid::Vector{Float64})

Calculates the change in the number of particles of a Fermi Dirac distribution with respect to chemical potential

# Arguments
- &#39;μ&#39;: Electronic distribution
- &#39;Tel&#39;: The electronic bath temperature
- &#39;DOS&#39;: Density-of-states of the system
- &#39;egrid&#39;: Energy grid the simulation is solved over

# Returns
- The value of dn/dμ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/PropertyFunctions.jl#L72-L85">source</a></section></article><h3 id="Running-Dynamics"><a class="docs-heading-anchor" href="#Running-Dynamics">Running Dynamics</a><a id="Running-Dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Running-Dynamics" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.run_simulation-Tuple{LightMatter.Simulation, Dict{String, Float64}, Tuple{Float64, Float64}}" href="#LightMatter.run_simulation-Tuple{LightMatter.Simulation, Dict{String, Float64}, Tuple{Float64, Float64}}"><code>LightMatter.run_simulation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_simulation(sys::Dict{String,Union{Expr,Vector{Expr}}}, initialtemps::Dict{String, Float64},
tspan::Tuple{Float64,Float64}, sim::Simulation; 
save, tolerance, max_step, min_step, callbacks)

Generates the problem the dynamics will solve and then solves the coupled system of ODE&#39;s.
Currently always uses Tsit5 for the integration routine but in the future that may be user-defined

# Arguments
- &#39;sys&#39;: Dictionary of ODE equations to be propagated
- &#39;initialtemps&#39;: Dictionary of initial temperatures of the bath
- &#39;tspan&#39;: Tuple of values for the dynamics to run between (the laser is centred on 0.0)
- &#39;sim&#39;: Simulation settings and parameters

# KWARGS
- Any key-word arguemnts from DiffEq that work with ODEProblems can be including in a namedtuple here

# Returns
- The solution of the dynamics calculation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/RunDynamics.jl#L1-L20">source</a></section></article><h3 id="Outputting"><a class="docs-heading-anchor" href="#Outputting">Outputting</a><a id="Outputting-1"></a><a class="docs-heading-anchor-permalink" href="#Outputting" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.convert_symbols_to_strings-Tuple{Any}" href="#LightMatter.convert_symbols_to_strings-Tuple{Any}"><code>LightMatter.convert_symbols_to_strings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_symbols_to_strings(dict::Dict{Any,Any})

Converts any Symbol key values to their respecitve string for saving

# Arguments
- &#39;dict&#39;: The dictionary which needs keys converting

# Returns
- Dictionary with all Symbol keys changed to strings</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/OutputProcessing.jl#L91-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.create_datafile_and_structure-Tuple{String}" href="#LightMatter.create_datafile_and_structure-Tuple{String}"><code>LightMatter.create_datafile_and_structure</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_datafile_and_structure(file_name::String)

Creates a file with the standard data structure:
- Athermal Electrons
- Density Matrix
- Electronic Temperature
- Phononic Temperature
- Electronic Distribution
- Phononic Distribution
- Laser
- Structure

# Arguments
- &#39;file_name&#39;: The name the user wishes the file to be saved as 

# Returns
- A created HDF5 file</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/OutputProcessing.jl#L40-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.dict_to_hdf5-Tuple{Any, Any}" href="#LightMatter.dict_to_hdf5-Tuple{Any, Any}"><code>LightMatter.dict_to_hdf5</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dict_to_hdf5(f,d::Dict{String,Any})

Unpacks a dictionary and saves it to the designated file location (f)

# Arguments
- &#39;f&#39;: Location in the HDF5 file the dictionary information will be saved to
- &#39;d&#39;: The dictionary to be unpacked and saved

# Returns
- Nothing returned but dictionary saved to location</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/OutputProcessing.jl#L71-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.extract_structure-Tuple{Any, Structure}" href="#LightMatter.extract_structure-Tuple{Any, Structure}"><code>LightMatter.extract_structure</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_structure(f, structure::Structure)

Specific way of writing structure settings to the file as both DOS and Dimension need special handling

# Arguments
- &#39;f&#39;: File to be written to
- &#39;structure&#39;: Structure settings and parameters

# Returns
- Nothing returned but structure parameters and settings wrote to file</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/OutputProcessing.jl#L178-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.generate_valuedict-Tuple{Any, LightMatter.Simulation, Any}" href="#LightMatter.generate_valuedict-Tuple{Any, LightMatter.Simulation, Any}"><code>LightMatter.generate_valuedict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_valuedict(sol, sim::Simulation, fields::Vector{Symbol})

Generates a dictionary of all propagated systems with placeholder arrays

# Arguments
- &#39;sol&#39;: The solution of the simulation
- &#39;sim&#39;: Simulation settings and parameters
- &#39;fields&#39;: Symbolic name of the propgated subsystems

# Returns
- Dictionary of values of each of the propgated subsystems</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/OutputProcessing.jl#L251-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.particlenumber_values-Tuple{LightMatter.Simulation}" href="#LightMatter.particlenumber_values-Tuple{LightMatter.Simulation}"><code>LightMatter.particlenumber_values</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">particlenumber_values(sim::Simulation)

Calculates the number of thermal electrons for a system when not propagated

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Array of the number of thermal electrons at each spatial point</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/OutputProcessing.jl#L324-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.populate_unpropagatedvalues!-Tuple{Dict{String, Float64}, Any, LightMatter.Simulation, Any}" href="#LightMatter.populate_unpropagatedvalues!-Tuple{Dict{String, Float64}, Any, LightMatter.Simulation, Any}"><code>LightMatter.populate_unpropagatedvalues!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">populate_unpropagatedvalues!(sol, initial_temps::Dict{String,Float64}, fields::Vector{Symbol}, sim::Simulation, vals::Dict{String,AbstractArray{Float64}})

Adds placeholder information to any unpropagated fields

# Arguments
- &#39;sol&#39;: The solution of the simulation
- &#39;initial_temps&#39;: Initial temperature the baths have been set to
- &#39;sim&#39;: Simulation settings and parameters
- &#39;fields&#39;: Symbolic name of the propgated subsystems
- &#39;vals&#39;: Dictionary of the propgated subsytems with placeholder arrays

# Returns
- vals dictionary with the added unpropagated subsystems</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/OutputProcessing.jl#L297-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.populate_value_dict!-Tuple{Any, Any, Any}" href="#LightMatter.populate_value_dict!-Tuple{Any, Any, Any}"><code>LightMatter.populate_value_dict!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">populate_value_dict!(sol ,fields::Vector{Symbol}, vals::Dict{String,AbstractArray{Float64}})

Populates the subsystem dictionary with the reuslting vlaues from the simulation

# Arguments
- &#39;sol&#39;: The solution of the simulation
- &#39;fields&#39;: Symbolic name of the propgated subsystems
- &#39;vals&#39;: Dictionary of the propgated subsytems with placeholder arrays

# Returns
- The vals dictionary with the actual results inside</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/OutputProcessing.jl#L275-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.post_production-Tuple{Any, String, Dict{String, Float64}, Vector{Symbol}, LightMatter.Simulation}" href="#LightMatter.post_production-Tuple{Any, String, Dict{String, Float64}, Vector{Symbol}, LightMatter.Simulation}"><code>LightMatter.post_production</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">post_production(sol,file_name::String,initial_temps::Dict{String,Float64},output::Symbol,sim::Simulation)

Handles processing, saving the simulation after it has completed. Uses HDF5 file format
Currently the only output setting supported is :minimum which only saves the parameters, chemical potential and
progated systems

# Arguments
- &#39;sol&#39;: The solution of the simulation
- &#39;file_name&#39;: The name the user wishes the file to be saved as 
- &#39;initial_temps&#39;: Initial temperature the baths have been set to
- &#39;output&#39;: The output method required - may change in future
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Nothing is returned but a file is created</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/OutputProcessing.jl#L6-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.seperate_results-Tuple{Any, Dict{String, Float64}, LightMatter.Simulation}" href="#LightMatter.seperate_results-Tuple{Any, Dict{String, Float64}, LightMatter.Simulation}"><code>LightMatter.seperate_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">seperate_results(sol, initial_temps::Dict{String,Float64}, sim::Simulation)

Seperates the results held inside of the solution object
Also fills all unpropagated subsystems with parameter/temp information where neccessary

# Arguments
- &#39;sol&#39;: The solution of the simulation
- &#39;initial_temps&#39;: Initial temperature the baths have been set to
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Dictionary of values of each of the seperated systems</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/OutputProcessing.jl#L229-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.write_DOS-Tuple{Structure}" href="#LightMatter.write_DOS-Tuple{Structure}"><code>LightMatter.write_DOS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_DOS(structure::Structure)

Handles converting the DOS splines into a writable format

# Arguments
- &#39;structure&#39;: Structure settings and parameters

# Returns
- Dictionary of the DOS</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/OutputProcessing.jl#L199-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.write_simulation-Tuple{Any, LightMatter.Simulation}" href="#LightMatter.write_simulation-Tuple{Any, LightMatter.Simulation}"><code>LightMatter.write_simulation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_simulation(f,sim::Simulation)

Writes all settings and parameters to their respective location in the file (f)

# Arguments
- &#39;f&#39;: File to be written to
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Nothing returned but all parameters and settings wrote to file</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/OutputProcessing.jl#L108-L119">source</a></section></article><h3 id="DOS-/-Geometry-Functions"><a class="docs-heading-anchor" href="#DOS-/-Geometry-Functions">DOS / Geometry Functions</a><a id="DOS-/-Geometry-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#DOS-/-Geometry-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.DOSScale!-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}}" href="#LightMatter.DOSScale!-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}}"><code>LightMatter.DOSScale!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DOSScale!(Temp::Matrix{Float64},bulk::Vector{Float64},Energies::Vector{Float64})

Ensures that all DOS are scaled to the same number of particles as the bulk

# Arguments
- &#39;Temp&#39;: Matrix of number of states in height X Energy
- &#39;bulk&#39;: The bulk DOS on the same energy grid as Temp
- &#39;Energies&#39;: The energy grid used for Temp and bulk

# Returns
- Temp with the rescaled DOS&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L290-L302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.DOS_initialization-Tuple{Union{Nothing, String, Vector{String}}, Union{Nothing, String, Vector{String}}, Union{Nothing, String}, Union{Nothing, String}, Float64, LightMatter.Dimension, Bool, Union{Nothing, Interpolations.AbstractExtrapolation}}" href="#LightMatter.DOS_initialization-Tuple{Union{Nothing, String, Vector{String}}, Union{Nothing, String, Vector{String}}, Union{Nothing, String}, Union{Nothing, String}, Float64, LightMatter.Dimension, Bool, Union{Nothing, Interpolations.AbstractExtrapolation}}"><code>LightMatter.DOS_initialization</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DOS_initialization(bulk_DOS::Union{String,Vector{String}}, bulk_geometry::String, DOS_folder::String, slab_geometry::String,
                   atomic_layer_tolerance::Float64, dimension::Dimension, zDOS::Bool, DOS::Union{Nothing, spl})

Determines the desired DOS configuration and assembles it accordingly

# Arguments
- &#39;bulk_DOS&#39;: The bulk DOS file location
- &#39;bulk_geometry&#39;: The bulk DOS geometry location
- &#39;DOS_folder&#39;: The folder where the atom-projected DOS&#39; are present
- &#39;slab_geometry&#39;: The geometry.in file used in the creation of the atom-projected DOS&#39;
- &#39;atomic_layer_tolerance&#39;: The minimum height 2 atoms need to be apart to be considered seperate layers (default = 0.1 nm)
- &#39;dim&#39;: The Dimension struct which holds the z-grid
- &#39;zDOS&#39;: Bool for enabling a spatially dependent DOS
&#39; &#39;DOS&#39;: Allows the user to use their own splined DOS, for other regions of the code it must be the same type as normal DOS

# Returns
- A spline or vector of splines for the desired DOS structure</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_DOS-Tuple{String, String}" href="#LightMatter.build_DOS-Tuple{String, String}"><code>LightMatter.build_DOS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_DOS(dos_file::String, geometry_file::String)

A convenient constructor for building a DOS from the DOS and geometry file.

# Arguments
- &#39;dos_file&#39;: Path to the total DOS file.
- &#39;geometry_file&#39;: Path to the geometry.in file

# Returns
- An interpolation object representing the DOS.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L85-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_group_velocity-Tuple{Union{Nothing, Vector{Float64}}, Union{Float64, Vector{Float64}}, Bool, Symbol, Structure}" href="#LightMatter.build_group_velocity-Tuple{Union{Nothing, Vector{Float64}}, Union{Float64, Vector{Float64}}, Bool, Symbol, Structure}"><code>LightMatter.build_group_velocity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_group_velocity(v_g::Union{Vector{Float64},Nothing}, FE::Union{Float64,Vector{Float64}}, Conductivity::Bool, conductive_velocity::Symbol, structure::Structure)

Creates a vector or array of vectors (spatial DOS) for the group veolcity for ballistic electron transport. Users can also provide a constant value in the form
of v_g, they must also set conductive_veolcity to constant.
Currently Implemented:
- :fermigas : Assumes a free electron gas solution therefore is an analytical form of the group velocity
- :effectiveoneband : Uses the effective one band model to convert a DOS into a group velocity, for more details see Mueller &amp; Rethfeld, Phys. Rev. B 87, 035139.
- :constant : Uses the v_g argument to set a constant group velocity for all energy ranges

# Arguments
- &#39;v_g&#39;: A constant group velocity value if :constant is requested
- &#39;FE&#39;: The Fermi energy, calculated from get_FermiEnergy
- &#39;Conductivity&#39;: Sets whether ballistic transport should be enabled
- &#39;conductive_velocity&#39;: The form the user wants the group velocity to take
- &#39;structure&#39;: Contains all structural information including DOS and number of elemental systems

# Returns
- The group velocity vector or array of vectors as requested by the user for ballistic electron transport</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L327-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_zDOSArray-Tuple{Vector{Float64}, String, Vector{String}, Vector{Float64}}" href="#LightMatter.build_zDOSArray-Tuple{Vector{Float64}, String, Vector{String}, Vector{Float64}}"><code>LightMatter.build_zDOSArray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_zDOSArray(egrid::Vector{Float64},folder::String,files::Vector{String},heights::Vector{Float64})

Builds a matrix of the DOS as a function of height and energy for the individual layers. 

# Arguments
- &#39;egrid&#39;: Energy grid the DOS is calculated on
- &#39;folder&#39;: The folder where the atom-projected DOS&#39; are present
- &#39;files&#39;: Vector of file names 
- &#39;heights&#39;: Vector of each file names height

# Returns
- A matrix of states as a function of height and energy</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L264-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.effective_one_band_velocity-Tuple{DataInterpolations.AkimaInterpolation, Interpolations.AbstractExtrapolation, Vector{Float64}, Float64}" href="#LightMatter.effective_one_band_velocity-Tuple{DataInterpolations.AkimaInterpolation, Interpolations.AbstractExtrapolation, Vector{Float64}, Float64}"><code>LightMatter.effective_one_band_velocity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">effective_one_band_velocity(DOS::spl, egrid::Vector{Float64}, FE::Float64)

Calculates the group velocity from the effective one band model.
For more details see Mueller &amp; Rethfeld, Phys. Rev. B 87, 035139.

# Arguments
- &#39;DOS&#39;: The density-of-states of the system
- &#39;egrid&#39;: Energy grid all distributions are solved on
- &#39;FE&#39;: The Fermi energy, calculated from get_FermiEnergy

# Returns
- The effective one band model group velocity as a vector or vector of vectors depending on the structure
of the system</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L435-L449">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.effective_onebandmodel-Tuple{Any, Vector{Float64}, Float64}" href="#LightMatter.effective_onebandmodel-Tuple{Any, Vector{Float64}, Float64}"><code>LightMatter.effective_onebandmodel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">effective_onebandmodel(DOS::spl, egrid::Vector{Float64}, FE::Float64)

Calculates the dispersion relation within the effective one band model.
For more details see Mueller &amp; Rethfeld, Phys. Rev. B 87, 035139.

# Arguments
- &#39;DOS&#39;: The density-of-states of the system
- &#39;egrid&#39;: Energy grid all distributions are solved on
- &#39;FE&#39;: The Fermi energy, calculated from get_FermiEnergy

# Returns
- The effective one band model dispersion relation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L468-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.generate_DOS-Tuple{String, Float64}" href="#LightMatter.generate_DOS-Tuple{String, Float64}"><code>LightMatter.generate_DOS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_DOS(File::String, unit_scalar::Float64)

Generates a spline of a DOS from a file. Assumes the structure of the DOS is column 1 is Energy in eV
and column 2 is States in eV⁻¹V⁻¹ (volume of unit cell) 

# Arguments
- &#39;File&#39;: Path to the total DOS file.
- &#39;unit_scalar&#39;: Scalar to convert the units (1/V in nm⁻³).

# Returns
- An interpolation object representing the DOS.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L68-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.get_FermiEnergy-Tuple{String}" href="#LightMatter.get_FermiEnergy-Tuple{String}"><code>LightMatter.get_FermiEnergy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_FermiEnergy(File::String)

Calculates the Fermi energy defined as the difference between 0.0 and the
bottom of the valence band. Assumes the DOS provided has the Fermi energy
set to 0.0.

# Arguments
- &#39;File&#39;: Path to a file containing the density of states data.

# Returns
- The Fermi energy calculated at the bottom of the valence band.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L50-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.get_atomiclayers-Tuple{Matrix{Float64}, Float64}" href="#LightMatter.get_atomiclayers-Tuple{Matrix{Float64}, Float64}"><code>LightMatter.get_atomiclayers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_atomiclayers(atoms::Matrix{Float64},tolerance::Float64)

Seperats the atoms into their layers and selects a single atom from each layer. To remove degeneracy for 
larger supercell structures.

# Arguments
- &#39;atoms&#39;: Matrix of the atom number and it&#39;s repseictve coordinates
- &#39;tolerance&#39;: The minimum height 2 atoms need to be apart to be considered seperate layers (default = 0.1Å)

# Returns
- A trimmed matrix of atoms now containing one atom per layer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L235-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.get_fermigas_dos-Tuple{Vector{Float64}, Float64}" href="#LightMatter.get_fermigas_dos-Tuple{Vector{Float64}, Float64}"><code>LightMatter.get_fermigas_dos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_fermigas_dos(egrid, FE)

Function for calculating a free electron gas.

# Arguments
- &#39;egrid&#39;: Energy grid all distributions are solved on
- &#39;FE&#39;: The Fermi energy, calculated from get_FermiEnergy

# Returns
- The free electron gas denisty-of-states</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L417-L428">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.get_fermigas_velocity-Tuple{Vector{Float64}, Float64}" href="#LightMatter.get_fermigas_velocity-Tuple{Vector{Float64}, Float64}"><code>LightMatter.get_fermigas_velocity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_fermigas_velocity(egrid::Vector{Float64}, EF::Float64)

The analytical free electron gas group velocity, requested by conductive_velocity = :fermigas

# Arguments
- &#39;egrid&#39;: Energy grid all distributions are solved on
- &#39;FE&#39;: The Fermi energy, calculated from get_FermiEnergy

# Returns
- The free electron gas group velocity</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L402-L413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.get_files_heights_forDOS-Tuple{String, String, Float64}" href="#LightMatter.get_files_heights_forDOS-Tuple{String, String, Float64}"><code>LightMatter.get_files_heights_forDOS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_files_heights_forDOS(folder::String,geometry::String,tolerance::Float64)

Extracts atom from geometry, removes all bar one from each layer defined by tolerance, then connects the atom
to the corresponding file in the folder of DOS&#39;. Readjusts the heights to set the top layer to 0.0 and the
lower layers to increase from there. 

# Arguments
- &#39;folder&#39;: The folder where the atom-projected DOS&#39; are present
- &#39;geometry&#39;: The geometry.in file used in the creation of the atom-projected DOS&#39;
- &#39;tolerance&#39;: The minimum height 2 atoms need to be apart to be considered seperate layers (default = 0.1Å)

# Returns
- A vector of DOS files and their respective heights</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L168-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.get_interpolant-Tuple{Any, Any}" href="#LightMatter.get_interpolant-Tuple{Any, Any}"><code>LightMatter.get_interpolant</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_interpolant(xvals::Vector{Float64},yvals::Vector{Float64})

Generates a linear spline of any two vectors with a constant extrapolation applied to the boundaries.

# Arguments
- &#39;xvals&#39;: x-axis of the desired spline
- &#39;yvals&#39;: y-axis of the desired spline

# Returns
- Spline of yvals vs xvals</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L314-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.get_slabgeometry-Tuple{String}" href="#LightMatter.get_slabgeometry-Tuple{String}"><code>LightMatter.get_slabgeometry</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_slabgeometry(file_path::String)

Extracts the atoms and their coordinates from a FHI-aims slab geometry.in file. It ignores any 
atoms that have their relaxation constrained. 

# Arguments
- &#39;file_path&#39;: The geometry.in file used in the creation of the atom-projected DOS&#39;

# Returns
- A matrix of the atom number and their coordinates</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L203-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.get_unitcellvolume-Tuple{String}" href="#LightMatter.get_unitcellvolume-Tuple{String}"><code>LightMatter.get_unitcellvolume</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_unitcellvolume(geometry_file::String)

Calculates the volume of the unit cell for DOS unit conversion

# Arguments
- &#39;geometry_file&#39;: Path to the geometry.in file

# Returns
- Volume of the unit cell in nm⁻³</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L101-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.spatial_DOS-Tuple{String, String, String, Float64, LightMatter.Dimension, Float64}" href="#LightMatter.spatial_DOS-Tuple{String, String, String, Float64, LightMatter.Dimension, Float64}"><code>LightMatter.spatial_DOS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spatial_DOS(folder::String,geometry::String,bulk::String,Vbulk::Float64,dim::Dimension,tolerance::Float64)

Creates a spline of a DOS at each z-grid point in the simulation. Reads a folder of atom projected DOS&#39;s and the 
respective geomwtry.in file to determine the height of each DOS and interpolates between them to create the final
DOS&#39;

# Arguments
- &#39;folder&#39;: The folder where the atom-projected DOS&#39; are present
- &#39;geometry&#39;: The geometry.in file used in the creation of the atom-projected DOS&#39;
- &#39;bulk&#39;: The bulk DOS file location
- &#39;Vbulk&#39;: The volume of the bulk unit cell
- &#39;dim&#39;: The Dimension struct which holds the z-grid
- &#39;tolerance&#39;: The minimum height 2 atoms need to be apart to be considered seperate layers (default = 0.1 nm)

# Returns
- A vector of splines corresponding to the DOS at each z-height</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/DOS_Geometry.jl#L130-L147">source</a></section></article><h4 id="Unit-Handling"><a class="docs-heading-anchor" href="#Unit-Handling">Unit Handling</a><a id="Unit-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-Handling" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.convert_units-Tuple{Unitful.FreeUnits, Any}" href="#LightMatter.convert_units-Tuple{Unitful.FreeUnits, Any}"><code>LightMatter.convert_units</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_units(value::Union{Quantity, AbstractArray{&lt;:Quantity}, Float64, AbstractArray{Float64}})

Converts any user-given parameters that they have attached units to, to the correct units for LightMatter.jl
All values without Unitful.jl units attached are assumed to be in the correct units given by LightMatter_units

# Arguments
- &#39;value&#39;: The value(array of values) of the parameter, either as a Unitful.jl Quantity or a Float64

# Returns
- The Quantity converted into LightMatter.jl&#39;s preferred units, or the Float64 left as is</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/UnitManagement.jl#L10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.BaseUnits" href="#LightMatter.BaseUnits"><code>LightMatter.BaseUnits</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BaseUnits = 

Global Tuple for conversion factors from base SI units to base LightMatter units</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/UnitManagement.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.Constants" href="#LightMatter.Constants"><code>LightMatter.Constants</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Constants = (ħ = 0.6582 eVfs, kB = 8.617e-5 eV/K, me = 5.686 eVm)

Global named tuple for accessing constant physical values during a Simulation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/UnitManagement.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.LightMatter_units" href="#LightMatter.LightMatter_units"><code>LightMatter.LightMatter_units</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LightMatter_units

A list of the units used in LightMatter.jl: Please convert all units to this</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/UnitManagement.jl#L55-L59">source</a></section></article><h3 id="System-Construction"><a class="docs-heading-anchor" href="#System-Construction">System Construction</a><a id="System-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#System-Construction" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_backgroundTTM-Tuple{LightMatter.Simulation}" href="#LightMatter.build_backgroundTTM-Tuple{LightMatter.Simulation}"><code>LightMatter.build_backgroundTTM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_backgroundTTM(sim::Simulation)

Builds the structs for the TTM to be used in the sub-surface layers of the embedding AthEM nmethod

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Simulation struct setup to perform the background TTM for the embedded AthEM method</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SystemConstruction.jl#L27-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.build_loopbody-Tuple{Any, LightMatter.Simulation}" href="#LightMatter.build_loopbody-Tuple{Any, LightMatter.Simulation}"><code>LightMatter.build_loopbody</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_loopbody(sys, sim::Simulation)

Builds the multi-threaded section of the ODE problem

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Quote block for the multithreaded section of the ODE problem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SystemConstruction.jl#L257-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.conductivity_expressions-Tuple{LightMatter.Simulation}" href="#LightMatter.conductivity_expressions-Tuple{LightMatter.Simulation}"><code>LightMatter.conductivity_expressions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conductivity_expressions(sim::Simulation)

Creates vector of expressions for the different conductivities occuring during the simulation

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Vector of expression for the conductivity of each subsytem if they are enabled</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SystemConstruction.jl#L233-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.function_builder-Tuple{LightMatter.Simulation}" href="#LightMatter.function_builder-Tuple{LightMatter.Simulation}"><code>LightMatter.function_builder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function_builder(sim::Simulation)

Assembles the correct dictionary of equations for the subsystems that are propagated. Mainly used for
seperating embedded and un-embedded methods

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Dictionary of subsystem names and their respective equation / expression</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SystemConstruction.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.generate_expressions-Tuple{LightMatter.Simulation, Expr}" href="#LightMatter.generate_expressions-Tuple{LightMatter.Simulation, Expr}"><code>LightMatter.generate_expressions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_expressions(sim::Simulation, laser::Expr)

Calculates and groups each subsystems expression in turn into a dictionary

# Arguments
- &#39;sim&#39;: Simulation settings and parameters
- &#39;laser&#39;: Expression for the temporal evolution and spatial decay of the laser

# Returns
- Dictionary of subssytems and their respective expressions</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SystemConstruction.jl#L46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.generate_initialconditions-Tuple{LightMatter.Simulation, Dict{String, Float64}}" href="#LightMatter.generate_initialconditions-Tuple{LightMatter.Simulation, Dict{String, Float64}}"><code>LightMatter.generate_initialconditions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_initialconditions(sim::Simulation, initialtemps::Dict{String, Float64})

Generates the initial conditions (u0) NamedArrayPartition for the ODE 

# Arguments
- &#39;sim&#39;: Simulation settings and parameters
- &#39;initialtemps&#39;: Dictionary containing initial temepratures for electronic and phononic baths

# Returns
- NamedArrayPartition containing the initial conditions of the simulation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SystemConstruction.jl#L76-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.generate_parameters-Tuple{LightMatter.Simulation, Dict{String, Float64}}" href="#LightMatter.generate_parameters-Tuple{LightMatter.Simulation, Dict{String, Float64}}"><code>LightMatter.generate_parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_initialconditions(sim::Simulation, initialtemps::Dict{String, Float64})

Generates the parameters as a NamedTuple for the ODE 

# Arguments
- &#39;sim&#39;: Simulation settings and parameters
- &#39;initialtemps&#39;: Dictionary containing initial temepratures for electronic and phononic baths

# Returns
- NamedTuple containing the parameters of the simulation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SystemConstruction.jl#L121-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.monometallic_system-Tuple{Any, LightMatter.Simulation}" href="#LightMatter.monometallic_system-Tuple{Any, LightMatter.Simulation}"><code>LightMatter.monometallic_system</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">monometallic_system(sys, sim::Simulation)

Creates the expression block for the entire ODE function including multithreading.
This function is sepcfically for a monometallic system, Elemental_System == 1

# Arguments
- &#39;sys&#39;: Dictionary of expressions for each subssytem propagated
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Quote block for the monometallic problem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SystemConstruction.jl#L209-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.simulation_construction-Tuple{Any, LightMatter.Simulation}" href="#LightMatter.simulation_construction-Tuple{Any, LightMatter.Simulation}"><code>LightMatter.simulation_construction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulation_construction(sys, sim::Simulation)

Creates the expression block for the entire ODE function including multithreading.
This function calls monometallic_system or antenna_reactor_system respectively.

# Arguments
- &#39;sys&#39;: Dictionary of expressions for each subssytem propagated
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Quote block for the entire ODE problem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SystemConstruction.jl#L189-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.variable_renaming-Tuple{LightMatter.Simulation}" href="#LightMatter.variable_renaming-Tuple{LightMatter.Simulation}"><code>LightMatter.variable_renaming</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variable_renaming(sim::Simulation)

Renames variables such as u.x or p.y to just x or y so that during expression evaluation they 
are named correctly. 

# Arguments
- &#39;sim&#39;: Simulation settings and parameters

# Returns
- Expression for the variabble renaming to enter the top of the multithreaded loop</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/SystemConstruction.jl#L313-L324">source</a></section></article><h3 id="Antenna-Reactor-Construction"><a class="docs-heading-anchor" href="#Antenna-Reactor-Construction">Antenna-Reactor Construction</a><a id="Antenna-Reactor-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Antenna-Reactor-Construction" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.antenna_reactor_system-Tuple{Dict{String, Union{Expr, Vector{Expr}}}, LightMatter.Simulation}" href="#LightMatter.antenna_reactor_system-Tuple{Dict{String, Union{Expr, Vector{Expr}}}, LightMatter.Simulation}"><code>LightMatter.antenna_reactor_system</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">antenna_reactor_system(sys, sim)

Constructs the main expression for an antenna reactor simulation system.

# Arguments
- `sys`::Dict{String, Union{Expr, Vector{Expr}}}
       A dictionary or configuration object containing the expressions for each system propagated
- `sim`::Simulation
       A simulation object containing all necessary input data for the simulation.

# Returns
- An expression block containing the time output, conductivity expressions, and a threaded simulation loop.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AntennaReactor.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.ar_variable_renaming-Tuple{LightMatter.Simulation}" href="#LightMatter.ar_variable_renaming-Tuple{LightMatter.Simulation}"><code>LightMatter.ar_variable_renaming</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ar_variable_renaming(sim)

Generates variable renaming expressions for translation between the variibale names in DiffEq.jl and LightMatter.jl

# Arguments
- `sim`::Simulation
       The Simulation struct containing all information about the simulation

# Returns
- An expression block assigning simulation-specific variable names.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AntennaReactor.jl#L52-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.mat_picker-Tuple{Float64, Union{Float64, Vector{Float64}}}" href="#LightMatter.mat_picker-Tuple{Float64, Union{Float64, Vector{Float64}}}"><code>LightMatter.mat_picker</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mat_picker(height, cutoffs)

Selects an index based on material interface height and given cutoffs.

# Arguments
- `height`::Float64
          The height value to compare.
- `cutoffs`::Union{Float64,Vector{Float64}}
           A vector of cutoff heights defining material regions.

# Returns
- The index of the region in which `height` lies.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AntennaReactor.jl#L26-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.sim_seperation-Tuple{LightMatter.Simulation}" href="#LightMatter.sim_seperation-Tuple{LightMatter.Simulation}"><code>LightMatter.sim_seperation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sim_seperation(sim)

Splits a composite `Simulation` object into separate simulations for each elemental subsystem.

# Arguments
- `sim`::Simulation
       The composite simulation containing multiple subsystems.

# Returns
- A vector of `Simulation` objects, each corresponding to a single elemental subsystem.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AntennaReactor.jl#L124-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.split_grid-Tuple{Vector{Float64}, Union{Float64, Vector{Float64}}}" href="#LightMatter.split_grid-Tuple{Vector{Float64}, Union{Float64, Vector{Float64}}}"><code>LightMatter.split_grid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_grid(grid, cutoffs)

Splits a numerical grid into regions that connect to each material

# Arguments
- `grid`::Vector{Float64}
        A vector of Float64 numbers representing the full z-grid
- `cutoffs`::Union{Float64, Vector{Float64}}
           A single value or vector of values defining the interfaces between each material 

# Returns
- A vector of sub-vectors representing segments of the original z-grid.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AntennaReactor.jl#L203-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.split_struct-Tuple{LightMatter.SimulationTypes, Int64}" href="#LightMatter.split_struct-Tuple{LightMatter.SimulationTypes, Int64}"><code>LightMatter.split_struct</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_struct(data, number)

Splits fields of a composite object with vector fields into a vector of scalar instances.

# Arguments
- `data`::SimulationTypes 
        A subsystem of the simulation e.g. AthermalElectrons or ElectronicTemperature
- `number`::Int 
          Number of different elemental systems.

# Returns
- A vector of the subsystem with scalar data extracted from the original vector fields.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AntennaReactor.jl#L153-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightMatter.split_structure-Tuple{Structure}" href="#LightMatter.split_structure-Tuple{Structure}"><code>LightMatter.split_structure</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_structure(structure)

Splits a `Structure` object into multiple structures if `DOS` is a vector. Different to split_struct due to the possibility 
of spatially resolved DOS&#39; though currently that isn&#39;t implemented

# Arguments
- `structure`::Structure
             The struct containing the information of the simulatkion structure

# Returns
- A vector of `Structure` objects, one per element if applicable.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maurergroup/LightMatter.jl/blob/b347c1d071efeab3d5c0f776d3c791667dada849/src/AntennaReactor.jl#L177-L189">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../units/">« Unit Management</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 1 August 2025 11:08">Friday 1 August 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
