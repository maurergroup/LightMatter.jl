<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · LightMatter.jl</title><meta name="title" content="Getting Started · LightMatter.jl"/><meta property="og:title" content="Getting Started · LightMatter.jl"/><meta property="twitter:title" content="Getting Started · LightMatter.jl"/><meta name="description" content="Documentation for LightMatter.jl."/><meta property="og:description" content="Documentation for LightMatter.jl."/><meta property="twitter:description" content="Documentation for LightMatter.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LightMatter.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../Tutorials/antennareactor/">Antenna Reactor Complex Simulation</a></li><li><a class="tocitem" href="../Tutorials/athem/">AthEM Simulation</a></li><li><a class="tocitem" href="../Tutorials/boltzmann/">Boltzmann Simulation</a></li><li><a class="tocitem" href="../Tutorials/dipoleapproximation/">Dipole Approximation Density Matrix Simulation</a></li><li><a class="tocitem" href="../Tutorials/surfaces/">Surface-Dependent Electronic Structure Simulation</a></li><li><a class="tocitem" href="../Tutorials/twotemperaturemodel/">1D Two-Temperature Model Simulation</a></li></ul></li><li><span class="tocitem">Systems</span><ul><li><a class="tocitem" href="../Systems/athermalelectrons/">Athermal Electrons</a></li><li><a class="tocitem" href="../Systems/densitymatrix/">Density Matrix</a></li><li><a class="tocitem" href="../Systems/electronicdistribution/">Electronic Distribution</a></li><li><a class="tocitem" href="../Systems/electronictemperature/">Electronic Temperature</a></li><li><a class="tocitem" href="../Systems/lasers/">Lasers </a></li><li><a class="tocitem" href="../Systems/phononicdistribution/">Phononic Distribution</a></li><li><a class="tocitem" href="../Systems/phononictemperature/">Phonon Temperature</a></li><li><a class="tocitem" href="../Systems/structure/">Structure</a></li></ul></li><li><a class="tocitem" href="../outputting/">Post Processing</a></li><li><a class="tocitem" href="../units/">Unit Management</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/maurergroup/LightMatter.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/maurergroup/LightMatter.jl/blob/main/docs/src/gettingstarted.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="getting-started"><a class="docs-heading-anchor" href="#getting-started">Getting started</a><a id="getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#getting-started" title="Permalink"></a></h1><p>To get started we shall assemble a classical two-temperature model(TTM) in 0D for gold. For how  to extend this to a 1D simulation and include thermal transport see <a href="../Tutorials/twotemperaturemodel/#ttm">Two Temperature Model</a>. We shall use Unitful to make handling units easier. Unitful quantities can be supplied to any parameter in LightMatter.jl and the code will convert it to the correct unit system. For more on units see <a href="../units/#units">Unit Management</a></p><h3 id="Creating-our-systems"><a class="docs-heading-anchor" href="#Creating-our-systems">Creating our systems</a><a id="Creating-our-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-our-systems" title="Permalink"></a></h3><p>The 3 main systems that comprise a Two-Temperature Model are an electronic temperature, a phononic temperature and a laser that drives the electronic system. The equation of motion for the TTM in 0D is given below:</p><p class="math-container">\[    C_\text{el}\frac{\partial T_\text{el}(t)}{\partial t} = -g(T_\text{el} + T_\text{ph}) + S(t) \\
    C_\text{ph}\frac{\partial T_\text{ph}(t)}{\partial t} = g(T_\text{el} + T_\text{ph})\]</p><p>Here, <span>$S(t)$</span> is the equation for the laser, <span>$C_\text{x}$</span> is the heatcapacity of the respective  thermal bath and g is the electron-phonon coupling parameter.</p><p>In LightMatter.jl we need to create both thermal baths above as well as define an equation for our laser. This is all handed by &#39;build&#39; functions. We shall build the most simple of each of the three systems in turn. First, the electronic thermal bath.</p><pre><code class="language-julia hljs">    Tel = build_ElectronicTemperature(Enabled=true, Electron_PhononCoupling=true, ElectronicHeatCapacity=:linear,
        ElectronPhononCouplingValue=:constant, γ = 62.9u&quot;J/m^3/K^2&quot;, g = 0.3e17u&quot;J/s/m^3/K&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ElectronicTemperature(true, false, true, false, :linear, :constant, 3.92590920783582e-7, 0.0, 0.0, 0.0, 1.872452722338229e-7)</code></pre><p>This first system shows us the prototypical setup of building a system in LightMatter.jl. First, we turn the system on with &#39;Enabled = true&#39;. Next we decide what approximations we want to use, in this case we are using a constant electron-phonon coupling value and a linear electronic heat capacity defined as <span>$C_\text{el} = \gamma T_\text{el}$</span>. Finally we then add the required values as Unitful quantities so we don&#39;t have to worry about units.  For the phonon bath,</p><pre><code class="language-julia hljs">    Tph = build_PhononicTemperature(Enabled=true, Electron_PhononCoupling=true, PhononicHeatCapacity=:constant,
    Cph = 2.49e6u&quot;J/m^3/K&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PhononicTemperature(true, false, true, false, :constant, 0.0, 0.0, 0.0155413575954073, 0.0)</code></pre><p>The same principle applies here as for the electronic bath, but now we don&#39;t need to provide details about the coupling as the phonon bath assumes that there is an electronic system to couple to and the parameters are located there. We decided on a constant value of the phonon heat capacity and this is the only value we need to provide. Last but not least is the laser.</p><pre><code class="language-julia hljs">    Las = build_Laser(envelope=:Gaussian, FWHM=50.0u&quot;fs&quot;, ϕ=10.0u&quot;J/m^2&quot;, Transport=:optical, ϵ=16.3e-9u&quot;m&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Laser(:Gaussian, :optical, 50.0, 62.41509074460764, 0.0, 0.0, 16.3, 0.0, 0.0)</code></pre><p>Here we have chosen a gaussian envelope for the laser profile. To see the other options see <a href="../Systems/lasers/#lasers">Lasers</a>. We have provided a full-width half-maximum (FWHM) and a fluence (ϕ). The last two settings describe how the laser interacts with the material. <code>:optical</code> states that the interaction depends on the absorption coefficient (1/ϵ). ϵ is then the inverse of the absorption coefficient a.k.a the penetration depth.</p><p>Once we define all of our systems we combine them into the Simulation.</p><pre><code class="language-julia hljs">    Sim = build_Simulation(electronictemperature = Tel, phononictemperature = Tph, laser=Las)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LightMatter.Simulation(ElectronicTemperature(true, false, true, false, :linear, :constant, 3.92590920783582e-7, 0.0, 0.0, 0.0, 1.872452722338229e-7), PhononicTemperature(true, false, true, false, :constant, 0.0, 0.0, 0.0155413575954073, 0.0), AthermalElectrons(false, false, false, false, false, :FLT, :constant, :unity, :constant, 0.0, 0.0, 0.0, [NaN]), ElectronicDistribution(false, false, 1.0, 5.685621837291226), PhononicDistribution(false, false, 0.0, 3-element extrapolate(interpolate((::Vector{Int64},), ::Vector{Int64}, Gridded(Linear())), Flat()) with element type Float64:
 Ratios.SimpleRatio{Int64}(4, 1)
 Ratios.SimpleRatio{Int64}(5, 1)
 Ratios.SimpleRatio{Int64}(6, 1), 0.0), Structure(false, false, 1, 3-element extrapolate(interpolate((::Vector{Int64},), ::Vector{Int64}, Gridded(Linear())), Flat()) with element type Float64:
 Ratios.SimpleRatio{Int64}(4, 1)
 Ratios.SimpleRatio{Int64}(5, 1)
 Ratios.SimpleRatio{Int64}(6, 1), DataInterpolations.AkimaInterpolation{Vector{Int64}, Vector{Int64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Int64}[DataInterpolations.AkimaInterpolation{Vector{Int64}, Vector{Int64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Int64}([1, 2, 3], [4, 5, 6], Float64[], [1.0, 1.0, 1.0], [0.0, 0.0], [0.0, 0.0], DataInterpolations.ExtrapolationType.Constant, DataInterpolations.ExtrapolationType.Constant, FindFirstFunctions.Guesser{Vector{Int64}}([4, 5, 6], Base.RefValue{Int64}(1), true), false, false), DataInterpolations.AkimaInterpolation{Vector{Int64}, Vector{Int64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Int64}([1, 2, 3], [4, 5, 6], Float64[], [1.0, 1.0, 1.0], [0.0, 0.0], [0.0, 0.0], DataInterpolations.ExtrapolationType.Constant, DataInterpolations.ExtrapolationType.Constant, FindFirstFunctions.Guesser{Vector{Int64}}([4, 5, 6], Base.RefValue{Int64}(1), true), false, false)], [-10.0, -9.99, -9.98, -9.97, -9.96, -9.95, -9.94, -9.93, -9.92, -9.91  …  9.91, 9.92, 9.93, 9.94, 9.95, 9.96, 9.97, 9.98, 9.99, 10.0], LightMatter.Dimension(1, [0.0], 1.0, 0.0), LightMatter.TotalFields(LightMatter.Fields([0.0, 0.0, 0.0], [0.0, 0.0, 0.0]), LightMatter.Fields([0.0, 0.0, 0.0], [0.0, 0.0, 0.0]))), Laser(:Gaussian, :optical, 50.0, 62.41509074460764, 0.0, 0.0, 16.3, 0.0, 0.0), DensityMatrix(false, Matrix{Complex}[[0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im], [0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im], [0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im]], LightMatter.Fields(Expr[:((.+)((sqrt.(((2 * sim.laser.ϕ * sqrt(4 * log(2))) .* 1.0) ./ (Constants.c * Constants.ϵ0 * sim.laser.FWHM * sim.laser.n * sqrt(pi))) .* exp((-2 * log(2) * t ^ 2) / sim.laser.FWHM ^ 2)) .* cos.(((sim.laser.hv * 1) / (Constants.ħ * 2 * pi)) * t), 0.0)), :((.+)(0.0 + 0.0, 0.0)), :((.+)(0.0 + 0.0, 0.0))], Expr[:((.+)(0.0 + 0.0, 0.0)), :((.+)(Expr[:((sqrt.(((2 * sim.laser.ϕ * sqrt(4 * log(2))) .* 1.0) ./ (Constants.c * Constants.ϵ0 * sim.laser.FWHM * sim.laser.n * sqrt(pi))) .* exp((-2 * log(2) * t ^ 2) / sim.laser.FWHM ^ 2)) .* cos.(((sim.laser.hv * 1) / (Constants.ħ * 2 * pi)) * t)), :(0.0 + 0.0), :(0.0 + 0.0)] ./ Constants.c, 0.0)), :((.+)(0.0 + 0.0, 0.0))]), Complex[0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im]))</code></pre><h3 id="Using-the-Simulation"><a class="docs-heading-anchor" href="#Using-the-Simulation">Using the Simulation</a><a id="Using-the-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-Simulation" title="Permalink"></a></h3><p>Now that we have the simulation we can go straight to running it if we desire. But before that we can have a look at the equations of motion that LightMatter.jl has constructed for our simulation. To do this we run,</p><pre><code class="language-julia hljs">    eom = LightMatter.function_builder(Sim)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Union{Expr, Vector{Expr}}} with 2 entries:
  &quot;Tph&quot; =&gt; :((0.0 + -1 * (-(sim.electronictemperature.g) * (Tel - Tph))) ./ sim…
  &quot;Tel&quot; =&gt; :((((sqrt((4 * log(2)) / pi) / sim.laser.FWHM) * exp((-4 * log(2) * …</code></pre><p>This returns us a dictionary for each of the equations of motion. In this case the keys are <code>&quot;Tel&quot;</code> and <code>&quot;Tph&quot;</code>. We can have a look at the equation of motion for the electronic thermal bath.</p><pre><code class="language-julia hljs">    eom[&quot;Tel&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">:((((sqrt((4 * log(2)) / pi) / sim.laser.FWHM) * exp((-4 * log(2) * t ^ 2) / sim.laser.FWHM ^ 2)) * (1 ./ sim.laser.ϵ) * ((1 .- sim.laser.R) .* sim.laser.ϕ) + -(sim.electronictemperature.g) * (Tel - Tph)) / (sim.electronictemperature.γ * Tel))</code></pre><p>This equation looks like what we would expect. We can see the beginning is the equation for a normalised gaussian laser. This is then followed by the subtraction of the electron-phonon coupling parameter multiplied by the temperature difference of the thermal baths and this is all divided by the expression for the heat capacity that we expected. </p><div class="admonition is-info" id="Note-a2fdf0fd42b625de"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a2fdf0fd42b625de" title="Permalink"></a></header><div class="admonition-body"><p>It&#39;s always a good idea when creating a new simulation type to check the different equations of motion and see if they are what you expect. Make sure that all of the parameters in the equation have been defined by yourself and saved in the correct place in the simulation.</p></div></div><p>We can now run a simulation by defining a couple initial temperatures and a time span,</p><pre><code class="language-julia hljs">    initialtemps=Dict(&quot;Tel&quot;=&gt;300.0,&quot;Tph&quot;=&gt;300.0)
    tspan=(-150.0, 1000.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-150.0, 1000.0)</code></pre><p>Finally, we can now run the simulation. We use the <code>OrdinaryDiffEq</code> package for performing the time integration and so all arguments used within a standard <code>solve</code> call can be used here. You can also use the <code>alg</code> keyword to define  any time integration algorithm supported by <code>OrdinaryDiffEq</code>. </p><pre><code class="language-julia hljs">    sol = run_simulation(Sim, initialtemps, tspan, saveat=1.0, abstol=1e-10, reltol=1e-10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: 1st order linear
t: 1151-element Vector{Float64}:
 -150.0
 -149.0
 -148.0
 -147.0
 -146.0
 -145.0
 -144.0
 -143.0
 -142.0
 -141.0
    ⋮
  992.0
  993.0
  994.0
  995.0
  996.0
  997.0
  998.0
  999.0
 1000.0
u: 1151-element Vector{RecursiveArrayTools.NamedArrayPartition{Float64, RecursiveArrayTools.ArrayPartition{Float64, Tuple{Vector{Float64}, Vector{Float64}}}, @NamedTuple{Tph::Int64, Tel::Int64}}}:
 (Tph = [300.0], Tel = [300.0])
 (Tph = [300.00000000000006], Tel = [300.000000010539])
 (Tph = [300.0000000000002], Tel = [300.00000002518357])
 (Tph = [300.0000000000007], Tel = [300.0000000454816])
 (Tph = [300.00000000000136], Tel = [300.00000007361575])
 (Tph = [300.0000000000025], Tel = [300.0000001126737])
 (Tph = [300.00000000000415], Tel = [300.0000001664157])
 (Tph = [300.0000000000066], Tel = [300.0000002398222])
 (Tph = [300.00000000001006], Tel = [300.0000003406232])
 (Tph = [300.00000000001495], Tel = [300.0000004793324])
 ⋮
 (Tph = [346.93990297645223], Tel = [3985.0558443600876])
 (Tph = [346.9837328115791], Tel = [3984.620424881217])
 (Tph = [347.02755687271133], Tel = [3984.1850151867657])
 (Tph = [347.07137516003667], Tel = [3983.7496152780773])
 (Tph = [347.1151876737423], Tel = [3983.3142251564987])
 (Tph = [347.1589944140158], Tel = [3982.8788448233754])
 (Tph = [347.20279538104467], Tel = [3982.4434742800527])
 (Tph = [347.24659057501634], Tel = [3982.008113527879])
 (Tph = [347.29037999611853], Tel = [3981.572762568199])</code></pre><p>Due to using <code>RecursiveArrayTools</code> the solution output can be quite tricky to use. To make this easier for instant plotting / processing you can call the following to output a dictionary of the solution of each system as well as  the save times as <code>Array</code>&#39;s.</p><pre><code class="language-julia hljs">    results = LightMatter.seperate_results(sol, initialtemps, Sim)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Union{Float64, AbstractArray}} with 4 entries:
  &quot;Tph&quot;   =&gt; [300.0; 300.0; … ; 347.247; 347.29;;]
  &quot;noe&quot;   =&gt; [40.0;;]
  &quot;Tel&quot;   =&gt; [300.0; 300.0; … ; 3982.01; 3981.57;;]
  &quot;times&quot; =&gt; [-150.0, -149.0, -148.0, -147.0, -146.0, -145.0, -144.0, -143.0, -…</code></pre><p>The last thing to complete our first simulation is to save the results to a file. This can be handled by <code>post_production</code>. This will save the results and <code>Simulation</code> struct to a HDF5 file as well as can perform some automated post processing. To see what can be done check out <a href="../outputting/#outputs">Outputting</a>.</p><pre><code class="nohighlight hljs">    post_production(sol, &quot;Test.hdf5&quot;, initialtemps, [:ThermalFermiDistribution], Sim)</code></pre><h3 id="What&#39;s-next?"><a class="docs-heading-anchor" href="#What&#39;s-next?">What&#39;s next?</a><a id="What&#39;s-next?-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-next?" title="Permalink"></a></h3><p>Now that we&#39;ve covered the basics of performing a TTM, we&#39;re ready to explore all the capabilities of LightMatter.jl All the systems follow the same patterns of enabling, defining approximations and adding parameters but with a couple of extra notes when you start to perform more complicated simulations. Feel free to check out the Tutorials or Systems sections to found out more. The tutorials have the structure as  follows: Theory of the method implemented, Approximations that you can use, Performing the method in  LightMatter.jl.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../Tutorials/antennareactor/">Antenna Reactor Complex Simulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 1 August 2025 14:08">Friday 1 August 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
