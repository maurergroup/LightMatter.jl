var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"M. Uehlein, H. T. Snowden, C. Seibel, T. Held, S. T. Weber, R. J. Maurer and B. Rethfeld. Capturing non-equilibrium electron dynamics in metals accurately and efficiently (Mar 2025). Accessed on Jul 16, 2025, arXiv:2503.09479 [cond-mat].\n\n\n\nZ. Lin, L. V. Zhigilei and V. Celli. Electron-phonon coupling and electron heat capacity of metals under conditions of strong electron-phonon nonequilibrium. Physical Review B 77, 075133 (2008). Accessed on May 7, 2024. Publisher: American Physical Society.\n\n\n\n","category":"page"},{"location":"Tutorials/surfaces/#surface-dos","page":"Surface-Dependent Electronic Structure Simulation","title":"Surface-Dependent Electronic Structure Simulation","text":"","category":"section"},{"location":"units/#units","page":"Unit Management","title":"Unit Handling","text":"","category":"section"},{"location":"units/","page":"Unit Management","title":"Unit Management","text":"This page contains information on the units of the simulations.","category":"page"},{"location":"Systems/lasers/#lasers","page":"Lasers ","title":"Lasers ","text":"","category":"section"},{"location":"outputting/#outputs","page":"Post Processing","title":"Post Processing","text":"","category":"section"},{"location":"outputting/","page":"Post Processing","title":"Post Processing","text":"This page contains information on the units of the simulations.","category":"page"},{"location":"Systems/electronicdistribution/#electron-distribution","page":"Electronic Distribution","title":"Electronic Distribution","text":"","category":"section"},{"location":"Tutorials/antennareactor/#antenna-reactor","page":"Antenna Reactor Complex Simulation","title":"Antenna Reactor Complex Simulation","text":"","category":"section"},{"location":"gettingstarted/#getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"To get started we shall assemble a classical two-temperature model(TTM) in 0D for gold. For how  to extend this to a 1D simulation and include thermal transport see Two Temperature Model. We shall use Unitful to make handling units easier. Unitful quantities can be supplied to any parameter in LightMatter.jl and the code will convert it to the correct unit system. For more on units see Unit Management","category":"page"},{"location":"gettingstarted/#Creating-our-systems","page":"Getting Started","title":"Creating our systems","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The 3 main systems that comprise a Two-Temperature Model are an electronic temperature, a phononic temperature and a laser that drives the electronic system. The equation of motion for the TTM in 0D is given below:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"    C_textelfracpartial T_textel(t)partial t = -g(T_textel + T_textph) + S(t) \n    C_textphfracpartial T_textph(t)partial t = g(T_textel + T_textph)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Here, S(t) is the equation for the laser, C_textx is the heatcapacity of the respective  thermal bath and g is the electron-phonon coupling parameter.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"In LightMatter.jl we need to create both thermal baths above as well as define an equation for our laser. This is all handed by 'build' functions. We shall build the most simple of each of the three systems in turn. First, the electronic thermal bath.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"    Tel = build_ElectronicTemperature(Enabled=true, Electron_PhononCoupling=true, ElectronicHeatCapacity=:linear, \n        ElectronPhononCouplingValue=:constant, γ = 62.9u\"J/m^3/K^2\", g = 0.3e17u\"J/s/m^3/K\")","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"This first system shows us the prototypical setup of building a system in LightMatter.jl. First, we turn the system on with 'Enabled = true'. Next we decide what approximations we want to use, in this case we are using a constant electron-phonon coupling value and a linear electronic heat capacity defined as C_textel = gamma T_textel. Finally we then add the required values as Unitful quantities so we don't have to worry about units.  For the phonon bath,","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"    Tph = build_PhononicTemperature(Enabled=true, Electron_PhononCoupling=true, PhononicHeatCapacity=:constant, \n    Cph = 2.49e6u\"J/m^3/K\")","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The same principle applies here as for the electronic bath, but now we don't need to provide details about the coupling as the phonon bath assumes that there is an electronic system to couple to and the parameters are located there. We decided on a constant value of the phonon heat capacity and this is the only value we need to provide. Last but not least is the laser.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"    Las = build_Laser(envelope=:Gaussian, FWHM=50.0u\"fs\", ϕ=10.0u\"J/m^2\", Transport=:optical, ϵ=16.3e-9u\"m\")","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Here we have chosen a gaussian envelope for the laser profile. To see the other options see Lasers. We have provided a full-width half-maximum (FWHM) and a fluence (ϕ). The last two settings describe how the laser interacts with the material. :optical states that the interaction depends on the absorption coefficient (1/ϵ). ϵ is then the inverse of the absorption coefficient a.k.a the penetration depth.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Once we define all of our systems we combine them into the Simulation.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"    Sim = build_Simulation(electronictemperature = Tel, phononictemperature = Tph, laser=Las)","category":"page"},{"location":"gettingstarted/#Using-the-Simulation","page":"Getting Started","title":"Using the Simulation","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now that we have the simulation we can go straight to running it if we desire. But before that we can have a look at the equations of motion that LightMatter.jl has constructed for our simulation. To do this we run,","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"    eom = LightMatter.function_builder(Sim)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"This returns us a dictionary for each of the equations of motion. In this case the keys are \"Tel\" and \"Tph\". We can have a look at the equation of motion for the electronic thermal bath.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"    eom[\"Tel\"]","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"This equation looks like what we would expect. We can see the beginning is the equation for a normalised gaussian laser. This is then followed by the subtraction of the electron-phonon coupling parameter multiplied by the temperature difference of the thermal baths and this is all divided by the expression for the heat capacity that we expected. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"note: Note\nIt's always a good idea when creating a new simulation type to check the different equations of motion and see if they are what you expect. Make sure that all of the parameters in the equation have been defined by yourself and saved in the correct place in the simulation.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"We can now run a simulation by defining a couple initial temperatures and a time span,","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"    initialtemps=Dict(\"Tel\"=>300.0,\"Tph\"=>300.0)\n    tspan=(-150.0, 1000.0)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Finally, we can now run the simulation. We use the OrdinaryDiffEq package for performing the time integration and so all arguments used within a standard solve call can be used here. You can also use the alg keyword to define  any time integration algorithm supported by OrdinaryDiffEq. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"    sol = run_simulation(Sim, initialtemps, tspan, saveat=1.0, abstol=1e-10, reltol=1e-10)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Due to using RecursiveArrayTools the solution output can be quite tricky to use. To make this easier for instant plotting / processing you can call the following to output a dictionary of the solution of each system as well as  the save times as Array's.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"    results = LightMatter.seperate_results(sol, initialtemps, Sim)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The last thing to complete our first simulation is to save the results to a file. This can be handled by post_production. This will save the results and Simulation struct to a HDF5 file as well as can perform some automated post processing. To see what can be done check out Outputting.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"    post_production(sol, \"Test.hdf5\", initialtemps, [:ThermalFermiDistribution], Sim)","category":"page"},{"location":"gettingstarted/#What's-next?","page":"Getting Started","title":"What's next?","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now that we've covered the basics of performing a TTM, we're ready to explore all the capabilities of LightMatter.jl All the systems follow the same patterns of enabling, defining approximations and adding parameters but with a couple of extra notes when you start to perform more complicated simulations. Feel free to check out the Tutorials or Systems sections to found out more. The tutorials have the structure as  follows: Theory of the method implemented, Approximations that you can use, Performing the method in  LightMatter.jl.","category":"page"},{"location":"Systems/densitymatrix/#density-matrix","page":"Density Matrix","title":"Density Matrix","text":"","category":"section"},{"location":"api/#Simulation-Types-and-Constructors","page":"API","title":"Simulation Types & Constructors","text":"","category":"section"},{"location":"api/#LightMatter.AthermalElectrons","page":"API","title":"LightMatter.AthermalElectrons","text":"AthermalElectrons <: SimulationTypes\n    Enabled::Bool\n\n    AthermalElectron_ElectronCoupling::Bool # Enables coupling to an electronic bath\n    AthermalElectron_PhononCoupling::Bool # Enables coupling to a phononic bath\n    Conductivity::Bool # Provides conductivity of a ballistic nature using velocity given by v_g\n    EmbeddedAthEM::Bool #WIP!! Do not set to true\n\n    ElectronicRelaxation::Symbol # Implementations are Fermi Liquid Theory (:FLT) or constant (:constant)\n    PhononicRelaxation::Symbol # Implementations are constant (:constant) or quasiparticle scattering (:quasi)\n    ExcitationMatrixElements::Symbol # Implementation is only match internal energy (:unity)\n    Conductive_Velocity::Symbol # Implementation of how gorup velocity is calculated, :constant, :fermigas or :effectiveoneband\n    \n    FE::Union{Float64,Vector{Float64}} # Shifted Fermi energy to the bottom of the valence band for FLT relaxation and group velocity\n    τ::Union{Float64,Vector{Float64}} # Material dependent scale-factor for :FLT relaxation time or the constant value for :constant\n    τep::Union{Float64,Vector{Float64}} # Constant relaxation time for phonons\n    v_g::Union{Vector{Float64},Matrix{Float64}} # Group velocity of electrons calculated assuming a Fermi liquid with μ = FE\nend\n\nStruct that defines and holds all values for the propagation of athermal electrons\nEnabling this struct assumes an AthEM like system (https://arxiv.org/abs/2503.09479) so can be coupled to electronic\nand phononic thermal baths. Coupling implicitly assumes the other system is enabled.\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.DensityMatrix","page":"API","title":"LightMatter.DensityMatrix","text":"WIP!!!\nDensityMatrix <: SimulationTypes\n    Enabled::Bool = false\nend \n\nStruct that defines and holds all values for the density matrix propagation.\nThis Simulation object doesn't function or couple with the others due to the difference in propagation from coupled \nODE to a von-Neumann equation.\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.Dimension","page":"API","title":"LightMatter.Dimension","text":"Dimension <: SimulationTypes\n    length::Int # The length of the grid, not the depth of the slab\n    grid::AbstractArray{Float64} # The grid the simulation is solved over\n    spacing::Union{Float64, Vector{Float64}} #The spacing between grid points\n    InterfaceHeight::Union{Float64, Vector{Float64}} # Height sorted list of the interfaces between materials\nend\n\nStruct that contains all information regarding the spatial grid that the simulation is performed on.\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.ElectronicDistribution","page":"API","title":"LightMatter.ElectronicDistribution","text":"struct ElectronicDistribution <: SimulationTypes\n    Enabled::Bool = false\n\n    Electron_PhononCoupling::Bool = false\nend\nStruct that defines and holds all values for the propagation of an electronic distribution\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.ElectronicTemperature","page":"API","title":"LightMatter.ElectronicTemperature","text":"ElectronicTemperature <: SimulationTypes\n    Enabled::Bool = false\n\n    AthermalElectron_ElectronCoupling::Bool = false # Enables coupling to athermal electrons\n    Electron_PhononCoupling::Bool = false # Enables coupling to a phonon thermostat\n    Conductivity::Bool = false # Provides diffusive thermal conductivity\n\n    ElectronicHeatCapacity::Symbol = :linear # Whether to use linear (:linear), non-linear (:nonlinear) or constant :(constant)\n                                             # electronic heat capacity\n    ElectronPhononCouplingValue::Symbol = :constant # Whether to use constant (:constant) or variable (:variable)\n                                                    # electron phonon coupling\n\n    γ::Union{Float64,Vector{Float64}} = 1.0 # Specific heat capacity of electrons at room temperature for linear heat capacity\n    κ::Union{Float64,Vector{Float64}} = 1.0 # Thermal conductivity of electrons at room temperature\n    λ::Union{Float64,Vector{Float64}} = 1.0 # Electron-phonon mass enhancement factor for non-linear electron-phonon coupling\n    ω::Union{Float64,Vector{Float64}} = 1.0 # Second moment of phonon spectral function for non-linear electron-phonon coupling\n    g::Union{Float64,Vector{Float64}} = 1.0 # Constant electron-phonon coupling value \nend\n\nStruct that defines and holds all values for the propagation of an electronic temperature\nThis can be coupled solely to a thermal phonon bath for a Two-Temperature Model simulation or to athermal electrons\nfor AthEM propagation with relaxation. Coupling implicitly assumes the other system is enabled.\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.Fields","page":"API","title":"LightMatter.Fields","text":"Fields <: SimulationTypes\n    Electric::Expr # Expression for the magnitude of the electric field in the simulation\n    Nagnetic::Expr # Expression for the magnitude of the magnetic field in the simulation\nend\n\nStruct that contains all information regarding electromagnetic fields in the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.Laser","page":"API","title":"LightMatter.Laser","text":"Laser <: SimulationTypes\n    envelope::Symbol = :Gaussian # Currently implemented are :Gaussian, :HyperbolicSecant, :Lorentzian and :Rectangular\n    Transport::Symbol # :optical, :ballistic and :combined are the options for how the laser decays into a slab\n\n    FWHM::Float64 # The Full-Width Half-Maximum of the laser, for rectnagular half the length\n    ϕ::Float64 # The unabsorbed fluence of the laser\n    hv::Float64 # The photon frequency of the laser\n    ϵ::Union{Float64,Vector{Float64}} # The inverse of the absorption coefficient\n    R::Float64 # The reflectivity of the sample\n    δb::Union{Float64,Vector{Float64}} # The ballistic length of electrons\nend\n\nStruct that contains all laser parameters and any material parameters that affect laser absorption\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.PhononicDistribution","page":"API","title":"LightMatter.PhononicDistribution","text":"W.I.P!!!\nstruct PhononicDistribution <: SimulationTypes\n    Enabled::Bool = false\n\n    Electron_PhononCoupling::Bool = false\nend\nStruct that defines and holds all values for the propagation of a phononic distribution\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.PhononicTemperature","page":"API","title":"LightMatter.PhononicTemperature","text":"struct PhononicTemperature <: SimulationTypes\n    Enabled::Bool = false\n\n    AthermalElectron_PhononCoupling::Bool = false # Enables coupling to athermal electrons\n    Electron_PhononCoupling::Bool = false # Enables coupling to an electron thermostat\n    Conductivity::Bool = false # Provides diffusive thermal conductivity\n\n    PhononicHeatCapacity::Symbol = :constant # Whether to use constant (:constant) or non-linear/Simpson's Rule (:nonlinear) \n                                             # Phononic Heat Capacity\n    \n    θ::Union{Float64,Vector{Float64}} = 1.0 # Debye temperature for non-linear phonon heat capacity\n    n::Union{Float64,Vector{Float64}} = 1.0 # Atomic density for non-linear phonon heat capacity\n    Cph::Union{Float64,Vector{Float64}} = 1.0 # Constant phonon heat capacity\n    κ::Union{Float64,Vector{Float64}} = 1.0 # Constant phonon thermal conductivity\nend\nStruct that defines and holds all values for the propagation of a phononic temperature\nThis can be coupled solely to a thermal electronic bath for a Two-Temperature Model simulation or to athermal electrons\nfor AthEM propagation with phonon-relaxation. Coupling implicitly assumes the other system is enabled.\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.Simulation","page":"API","title":"LightMatter.Simulation","text":"struct Simulation <: SimulationTypes\n    densitymatrix::DensityMatrix\n    electronictemperature::ElectronicTemperature\n    phononictemperature::PhononicTemperature\n    athermalelectrons::AthermalElectrons\n    electronicdistribution::ElectronicDistribution\n    phononicdistribution::PhononicDistribution\n    structure::Structure\n    laser::Laser\nend\nThis struct contains all the others and is the main simulation object both in assembling a simulation and during it\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.SimulationTypes","page":"API","title":"LightMatter.SimulationTypes","text":"SimulationTypes\n\nParent type of all subtypes in LightMatter.jl\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.Structure","page":"API","title":"LightMatter.Structure","text":"Structure <: SimulationTypes\n    Spatial_DOS::Bool # Whether to vary the DOS with height - if so the DOS becomes a vector\n\n    Elemental_System::Int # The number of elemental systems, if > 1 then each constant and vector\n                        # of material parameters needs to become a vector of length=Elemental_System\n\n    DOS::Union{spl,Vector{spl},Vector{Vector{spl}}} # The density of states of the simulation\n    egrid::Vector{Float64} # An energy grid for electronic or phononic distributions to be solved on\n\n    dimension::Union{Dimension} # A struct holding all spatial grid structure (0D or 1D)\n    bandstructure::Union{Vector{<:DataInterpolations.AkimaInterpolation}, Vector{<:Vector{DataInterpolations.AkimaInterpolation}},Nothing} \n                    # The band structure of the simulation both in terms of k->E and E-> k\nend\n\nStruct that contains any spatial information including the DOS, the spatial grid to solve the simulation on and\nthe elemental composition of the simulation (e.g. an antenna-reactor system would contain two elemental systems)\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.TotalFields","page":"API","title":"LightMatter.TotalFields","text":"TotalFields <: SimulationTypes\n    laser::Fields # The laser fields in the simulation\n    external::Fields # The external fields in the simulation, e.g. a magnetic field\nend\n\nStruct that contains both the field generated by the laser and any external fields.\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.spl","page":"API","title":"LightMatter.spl","text":"spl=Interpolations.AbstractExtrapolation\n\nA convenience type definition to make type specificity easier throughout the code\n\n\n\n\n\n","category":"type"},{"location":"api/#LightMatter.build_AthermalElectrons-Tuple{}","page":"API","title":"LightMatter.build_AthermalElectrons","text":"build_AthermalElectrons(;structure::Structure, Enabled = false, AthermalElectron_ElectronCoupling = false, \n                        AthermalElectron_PhononCoupling = false, Conductivity = false, ElectronicRelaxation = :FLT, \n                        PhononicRelaxation = :constant, ExcitationMatrixElements = :unity, FE=0.0, τ=1.0, τep = 1000.0, \n                        v_g = nothing, Conductive_Velocity = :constant, EmbeddedAthEM = false)\n\nOuter constructor function to assemble the AthermalElectrons struct. Unit conversion is detected on all parameters.\nThe function will build the group veolcity if one isn't provided by the user.\nDefaults allow any unneccessary parameters for users simulation to be ignored.\n\n# Arguments\n- 'Enabled': Bool for enabling an athermal electron subssystem\n- 'structure': Structure struct, provide if you want the group velocity calculated for you\n- 'AthermalElectron_ElectronCoupling': Enables athermal electron - thermal electron coupling\n- 'AthermalElectron_PhononCoupling': Enables athermal electron - thermal phonon coupling\n- 'Conductivity': Bool for enabling athermal electron ballistic transport\n- 'ElectronicRelaxation': Method for calculating athermal electron lifetime due to e-e collisions, :FLT or :constant\n- 'PhononicRelaxation': Method for calculating athermal electron lifetime due to e-p collisions, :quasi or :constant\n- 'ExcitationMatrixElements': Decides method to calculate excitation matrix elements, only :unity is currently implemented\n- 'FE': unit = eV: The Fermi energy defined as the difference between the bottom of the valence band in the DOS and 0.0\n- 'τ': unit = fs: A material dependent scalar for the :FLT lifetime or the constant value for :constant e-e lifetime\n- 'τep': unit = fs: The constant lifetime for the athermal electrons due to electron-phonon coupling\n- 'v_g': unit = nm/fs: The group velocity of the ballistic electrons, for the user to define their own group velocity and will overwrite the \n         one calculated by build_group_velocity. Also the value used for a constant velocity.\n- 'Conductive_Velocity': Define the group velocity that build_group_velocity should use, :constant :fermigas, :effectiveoneband\n- 'EmbeddedAthEM': Bool for setting only the surface layer to AthEM and the rest a TTM. Can't be used alongside athermal electron\n                   transport\n\n# Returns\n- The AthermalElectrons struct with the users settings and parameters with any neccessary unit conversion.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_DensityMatrix-Tuple{}","page":"API","title":"LightMatter.build_DensityMatrix","text":"WIP!!!\nbuild_DensityMatrix(; Enabled = false)\n\nOnce implemented will build a density matrix and store Hamiltonian for propagation via the vonNeumann equation.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_Dimension","page":"API","title":"LightMatter.build_Dimension","text":"build_Dimension(grid=[0.0]::AbstractArray{Float64}, cutoff=0.0::Union{Vector{Float64},Float64})\n\nOuter constructor function to assemble the Dimension struct. The user provides an evenly spaced grid \nand sorted list of interface heights for antenna-reactor complexes. The user must ensure the length of \ncutoff = Elemental_System - 1. No unit conversion is performed when assembling this struct.\nDefaults allow any unneccessary parameters for users simulation to be ignored.\n\n# Arguments\n- 'grid': unit = nm: Vector representing spatial grid. If [0.0] then homogenous (0D) calculation is performed\n- 'cutoff': unit = nm:  Sorted list of all interface heights. Only used when Elemental_System > 1. \n\n# Returns\n- The Dimension struct with the users grid and interface heights\n\n\n\n\n\n","category":"function"},{"location":"api/#LightMatter.build_ElectronicDistribution-Tuple{}","page":"API","title":"LightMatter.build_ElectronicDistribution","text":"build_ElectronicDistribution(;Enabled = false, Electron_PhononCoupling = false, Ω=1.0, me = Constants.me)\n\nBoltzmann clacluations are currently WIP.\nOuter constructor function to assemble the ElectronicDistribution struct. Unit conversion is detected on all parameters.\nDefaults allow any unneccessary parameters for users simulation to be ignored. Recommended to use Unitful Quantity\nfor me due to the unusual mass units in LightMatter.jl\n\n# Arguments\n- 'Enabled': Bool for enabling the full electronic distriubtion propagation\n- 'Electron_PhononCoupling': Enables electronic distribution - phononic distribution bath coupling\n- 'me': unit = eVm : Mass of conduction electron in LightMatter.jl mass units\n\n# Returns\n- The ElectronicDistribution struct with the users settings and parameters with any neccessary unit conversion.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_ElectronicTemperature-Tuple{}","page":"API","title":"LightMatter.build_ElectronicTemperature","text":"build_ElectronicTemperature(; Enabled = false, AthermalElectron_ElectronCoupling = false, Electron_PhononCoupling = false, Conductivity = false,\n                           ElectronicHeatCapacity = :linear, ElectronPhononCouplingValue = :constant, γ = 1.0, κ = 1.0, λ = 1.0, ω = 1.0, g = 1.0)\n\nOuter constructor function to assemble the ElectronicTemperature struct. Unit conversion is detected on all parameters.\nDefaults allow any unneccessary parameters for users simulation to be ignored.\n\n# Arguments\n- 'Enabled': Bool for enabling an thermal electronic bath\n- 'AthermalElectron_ElectronCoupling': Enables athermal electron - thermal electron coupling\n- 'Electron_PhononCoupling': Enables electron bath - phonon bath coupling\n- 'Conductivity': Bool for enabling thermnal electron diffusive transport\n- 'ElectronicHeatCapacity': Method for calculating the electronic heat capacity, :linear or :nonlinear\n- 'ElectronPhononCouplingValue': Method for calculating the electron phonon coupling value, either :constant or :variable\n- 'γ': unit = eV/nm³/K²: Specific heat capacity of electronic bath for :linear ElectronicHeatCapacity\n- 'κ': unit = eV/fs/nm/K: Thermal conductivity of electrons at room temperature\n- 'λ': unit = unitless: Electron-phonon mass enhancement parameter\n- 'ω': unit = eV^2: The second moment of the phonon spectrum\n- 'g': unit = eV/fs/nm³/K: Constant value for the electron-phonon coupling if using :constant\n\n# Returns\n- The ElectronicTemperature struct with the users settings and parameters with any neccessary unit conversion.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_Laser-Tuple{}","page":"API","title":"LightMatter.build_Laser","text":"build_laser(;envelope=:Gaussian, FWHM=10.0, ϕ=10.0, hv=5.0, Transport=:optical, ϵ=1.0, R=0.0, δb=1.0)\n\nOuter constructor function to assemble the Laser struct. Can handle unit conversions if the user provides a \nunitful quantity to the laser. \nDefaults allow any unneccessary parameters for users simulation to be ignored.\n\n# Arguments\n- 'envelope': Symbol representing the shape of the envelope, :Gaussian, :HyperbolicSecant, :Lorentzian, :Rectangular\n- 'FWHM': unit = fs:  Full-Width Half-Maximum of the laser pulse or half the duration of the Rectangular laser ± 0.0\n- 'ϕ': unit = eV/nm²: The fluence of the laser \n- 'hv': unit = eV: The photon energy of the laser\n- 'Transport': The method of spatial transport of the laser, :optical, :ballistic, :combined\n- 'ϵ': unit = nm: The penetration depth of the material (1/α), for the :Optical & :Combined transport\n- 'R': unit = unitless:The reflectivity of the sample surface, leave at 0.0 if your provided fluence is the absorbed fluence\n- 'δb': unit = nm:The ballistic length of electrons, for :ballistic & :combined transport\n\n# Returns\n- The Laser struct with the user settings and neccessary values converted to the correct units\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_PhononicDistribution-Tuple{}","page":"API","title":"LightMatter.build_PhononicDistribution","text":"build_PhononicDistribution(;Enabled = false, Electron_PhononCoupling = false, Ω=1.0, me = Constants.me)\n\nBoltzmann clacluations are currently WIP.\nOuter constructor function to assemble the PhononicDistribution struct. Unit conversion is detected on all parameters.\nDefaults allow any unneccessary parameters for users simulation to be ignored. Recommended to use Unitful Quantity\nfor me due to the unusual mass units in LightMatter.jl\n\n# Arguments\n- 'Enabled': Bool for enabling the full phononic distriubtion propagation\n- 'Electron_PhononCoupling': Enables electronic distribution - phononic distribution bath coupling\n- 'cs': unit = nm/fs : Speed of sound of longitudinal mode\n= 'ED': unit = eV : Deybe energy of the material\n\n# Returns\n- The PhononicDistribution struct with the users settings and parameters with any neccessary unit conversion.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_PhononicTemperature-Tuple{}","page":"API","title":"LightMatter.build_PhononicTemperature","text":"build_PhononicTemperature(;Enabled = false, AthermalElectron_PhononCoupling = false, Electron_PhononCoupling = false, \n                           Conductivity = false, PhononicHeatCapacity = :linear, θ = 1.0, n = 1.0, Cph = 1.0, κ = 1.0)\n\nOuter constructor function to assemble the PhononicTemperature struct. Unit conversion is detected on all parameters.\nDefaults allow any unneccessary parameters for users simulation to be ignored.\n\n# Arguments\n- 'Enabled': Bool for enabling an thermal electronic bath\n- 'AthermalElectron_PhononCoupling': Enables athermal electron - thermal electron coupling\n- 'Electron_PhononCoupling': Enables electron bath - phonon bath coupling\n- 'Conductivity': Bool for enabling thermal phonon diffusive transport\n- 'PhononicHeatCapacity': Method for calculating the phononic heat capacity, :constant or :nonlinear\n- 'θ': unit = K: Debye temperature of the material\n- 'n': unit = atoms/nm³: Float64 of atoms per nm³\n- 'Cph': unit = eV/nm³/K: Constant heat capacity for :constant\n- 'κ': unit = eV/nm: Constant thermal conductivity of phonons\n\n# Returns\n- The PhononicTemperature struct with the users settings and parameters with any neccessary unit conversion.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_Simulation-Tuple{}","page":"API","title":"LightMatter.build_Simulation","text":"build_Simulation(;densitymatrix::Union{DensityMatrix,NamedTuple,Nothing}=nothing, electronictemperature::Union{ElectronicTemperature,NamedTuple,Nothing}=nothing,\n                       phononictemperature::Union{PhononicTemperature,NamedTuple,Nothing}=nothing, athermalelectrons::Union{AthermalElectrons,NamedTuple,Nothing}=nothing,\n                       electronicdistribution::Union{ElectronicDistribution,NamedTuple,Nothing}=nothing, phononicdistribution::Union{PhononicDistribution,NamedTuple,Nothing}=nothing,\n                       structure::Union{Structure,NamedTuple,Nothing}=nothing, laser::Union{Laser,NamedTuple,Nothing}=nothing)\n\nAssembles the full Simulation struct from the requested components. Any systems not provided to the function are disabled by default.\nThe user can send either a completed Struct of the correct type or a NamedTuple with the correct key-word arguments to assemble the struct directly within the function\nusing the representative build_x function where x is the subsystem.\n\n# Arguments\n- 'densitymatrix': The DensityMatrix subsystem\n- 'electronictemperature': The ElectronicTemperature subsystem\n- 'phononictemperature': The PhononicTemperature subsystem\n- 'athermalelectrons': The AthermalElectrons subsystem\n- 'electronicdistribution': The ElectronicDistribution subsystem\n- 'phononicdistribution': The PhononicDistribution subsystem\n- 'structure': The Structure subsystem\n- 'laser': The Laser subsystem\n\n# Returns\n- The PhononicTemperature struct with the users settings and parameters with any neccessary unit conversion.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_Structure-Tuple{}","page":"API","title":"LightMatter.build_Structure","text":"build_Structure(; las::Laser=build_Laser(), Spatial_DOS::Bool = false, Elemental_System::Int = 1, dimension::Dimension = build_Dimension(),\n                bulk_DOS::Union{String,Vector{String},Nothing} = nothing, DOS_folder::Union{String,Vector{String},Nothing} = nothing, \n                bulk_geometry::Union{String,Vector{String},Nothing} = nothing, slab_geometry::Union{String,Vector{String},Nothing} = nothing, \n                atomic_layer_tolerance::Union{Float64,Vector{Float64}} = 0.1, DOS::Union{spl,Vector{spl},Nothing} = nothing, \n                egrid::Union{Vector{Float64},Nothing} = nothing)\n\nOuter constructor function to assemble the Structure struct. No unit conversion is performed.\nAll DOS files must be in the format |energy (eV), states (eV⁻¹Vᵤ⁻¹)|. Comment lines (#) are ignored\nDefaults allow any unneccessary parameters for users simulation to be ignored.\n\n# Arguments\n- 'las': Laser struct, provide if not providing a pre-made energy grid\n- 'Spatial_DOS': Bool for determening whether the DOS is spatially resolved or bulk\n- 'Elemental_System': Float64 of different crystal systems in the structure\n- 'dimension': Dimension struct, provide if not wanting a 0D calculation\n- 'bulk_DOS': File location of the bulk DOS file\n- 'DOS_folder': Location of a folder containing atom projected DOS. These must be in units of (eV⁻¹atom⁻¹) and be .dat files\n- 'bulk_geometry': File location of the bulk DOS' geometry.in file\n- 'slab_geometry': File location of the geometry.in to create the atom projected DOS' found in DOS_folder\n- 'atomic_layer_tolerance': Minimum height spacing in Å for two atoms to be apart to be considered different layers\n- 'DOS': A user made DOS or vector of DOS' for the simulation if not wanting to use the DOS_initialization function. Will overwrite this function.\n         Must be of the type DataInterpolations.LinearInterpolation or a vector of them. It is advised to have extrapolation enabled just in case. \n- 'egrid': A user made energy grid if not wanting to use build_egrid function. Will overwrite this function. Must be an evenly spaced grid that\n           has length(egrid) % 4 == 1 for the numerical integration algorithm to work. \n- 'BandStructure': Contains splines of [k->E, E->k] for the evaluation of magnetotransport and group velocity\n\n# Returns\n- The Structure struct with the DOS and egrid assembled or provided by the user\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_egrid-Tuple{Any}","page":"API","title":"LightMatter.build_egrid","text":"build_egrid(hv)\n\nBuilds an energy grid with spacing of 0.01 eV, limits of -2*hv to 2*hv and ensures that length(egrid) % 4 == 1\n\n# Arguments\n- 'hv': Photon energy of the laser\n\n# Returns\n- Evenly spaced energy grid that is suitable for the numerical integration algorithm and of sufficient accuracy/discretisation for accurate dynamics\n\n\n\n\n\n","category":"method"},{"location":"api/#Athermal-Electron-Distribution","page":"API","title":"Athermal Electron Distribution","text":"","category":"section"},{"location":"api/#LightMatter.FE_initialization-Tuple{Union{String, Vector{String}}}","page":"API","title":"LightMatter.FE_initialization","text":"FE_initalization(bulk_DOS::Union{String, Vector{String}})\n\nInitializes Fermi energy based on bulk density of states. This is defined as the difference between the bottom of the\nvalence band and 0.0. This is required for calculations such as the ballistic velocity or athermal electron lifetime due\nto electronic interactions.\n\n# Arguments\n- `bulk_DOS`: (Array of) file path to bulk density-of-states\n\n# Returns\n- Fermi energy/energies for each DOS input.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.athem_electronelectroninteraction-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.athem_electronelectroninteraction","text":"athem_electronelectroninteraction(sim::Simulation)\n\nReturns an expression representing the electron-electron scattering term in the AthEM model.\n\n# Arguments\n- 'sim': settings of the desired simulation\n\n# Returns\n- Symbolic expression for relaxation or 0.0 if disabled.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.athem_electronelectronscattering!-NTuple{9, Any}","page":"API","title":"LightMatter.athem_electronelectronscattering!","text":"athem_electronelectronscattering(fdis::VectorTel::Float64,μ::Float64,sim::Simulation,fneq::Vector{Float64},DOS::spl,n::Float64,τee::Union{Float64,Vector{Float64}})\n\nCalculates the electron-electron scattering contribution using a modified relaxation time approximation.\n\n# Arguments\n- 'Tel': Electronic temperature of the system\n- 'μ': Chemical potential at the current temperature\n- 'sim': Simulation settings and parameters\n- 'fneq': Current non-equilibrium electron distribution\n- 'DOS': Spline of the density-of-states\n- 'n': The number of electrons in the thermal system\n- 'τee': The athermal electron lifetime\n\n# Returns\n- Change in the non-equilibrium distribution due to scattering with a thermal electronic system\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.athem_electrongeneration!-NTuple{6, Any}","page":"API","title":"LightMatter.athem_electrongeneration!","text":"athem_electrongeneration!(tmp::Vector, egrid::Vector{Float64},DOS::spl,ftotspl::spl,hv::Float64,M::Union{Float64,Vector{Float64}})\n\nComputes the shape of the distribution change due to electron generation.\n\n# Arguments\n- `tmp`: Temporary vector for in-place update\n- `egrid`: Energy grid.\n- `DOS`: Density of states spline.\n- `ftotspl::spl`: Spline of the total distribution.\n- `hv`: Photon energy.\n- `M`: Matrix elements.\n\n# Returns\n- Change in distribution due to electron generation\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.athem_electronphononinteraction-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.athem_electronphononinteraction","text":"athem_electronelectroninteraction(sim::Simulation)\n\nReturns an expression representing the athermal electron-phonon scattering term in the AthEM model.\n\n# Arguments\n- 'sim': settings of the desired simulation\n\n# Returns\n- Symbolic expression for relaxation or 0.0 if disabled.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.athem_holegeneration!-NTuple{6, Any}","page":"API","title":"LightMatter.athem_holegeneration!","text":"athem_holegeneration!(tmp::Vector, egrid::Vector{Float64},DOS::spl,ftotspl::spl,hv::Float64,M::Union{Float64,Vector{Float64}})\n\nComputes the shape of the distribution change due to hole generation.\n\n# Arguments\n- `tmp`: Temporary vector for in-place update\n- `egrid`: Energy grid.\n- `DOS`: Density of states spline.\n- `ftotspl::spl`: Spline of the total distribution.\n- `hv`: Photon energy.\n- `M`: Matrix elements.\n\n# Returns\n- Change in distribution due to hole generation\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.athem_thermalelectronparticlechange-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.athem_thermalelectronparticlechange","text":"athem_thermalelectronparticlechange(sim::Simulation)\n\nReturns an expression for the total thermal electronum number due to relaxation and optional conductivity.\n\n# Arguments\n- 'sim': settings of the desired simulation\n\n# Returns\n- Expr for the time dependence of the thermal electron number.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.athemdistribution_factory-Tuple{LightMatter.Simulation, Expr}","page":"API","title":"LightMatter.athemdistribution_factory","text":"athemdistribution_factory(sim, laser_expr)\n\nConstructs the time evolution of the non-equilibrium distribution in the AthEM model\nFind out more at https://arxiv.org/abs/2503.09479\n\n# Arguments\n- `sim`::Simulation\n       Simulation struct containing physical and model parameters.\n- `laser_expr`::Expr\n              Expression representing the laser excitation term.\n\n# Returns\n- The total expression for the evolution of the athermal electron distribution, combining excitation and scattering terms.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.athemexcitation!-Tuple{Any, Any, Any, Any, Any, Float64, Any}","page":"API","title":"LightMatter.athemexcitation!","text":"athemexcitation!(Δfneqe::DiffCache, Δfneqh::DiffCache, ftot::Vector{Float64}, egrid::Vector{Float64}, DOS::spl, hv::Float64, M::Union{Float64,Vector{Float64}})\n\nComputes the net non-equilibrium excitation using Fermi's Golden Rule.\n\n# Arguments\n- 'Δfneqe': A pre-initialized vector to reduce allocations. Can be DiffCache or Vector. \n            This vector contains the final result\n- 'Δfneqh': A pre-initialized vector to reduce allocations. Can be DiffCache or Vector.\n- `ftot`: Total distribution (f_eq + f_neq).\n- `egrid`: Energy grid.\n- `DOS`: Density of states spline.\n- `hv`: Photon energy.\n- `M`: Matrix elements.\n\n# Returns\n- In-place normalized change in particle distribution shape. Multiply by inputted laser energy at time t to get \n  full excitation shape change\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.athemexcitation_matrixelements-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.athemexcitation_matrixelements","text":"athemexcitation_matrixelements(sim::Simulation)\n\nReturns the symbolic matrix element expression for photo-excitation.\nCurrently implemented:\n- :unity : No specified matrix elements - Returns 1.0\n\n# Arguments\n- 'sim': settings of the desired simulation\n\n# Returns\n- Matrix element expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_athemdistribution-Tuple{LightMatter.Simulation, Expr, Union{Float64, Expr}, Union{Float64, Expr}}","page":"API","title":"LightMatter.build_athemdistribution","text":"build_athemdistribution(sim, athemexcite, Elecelec, Elecphon)\n\nCombines excitation and scattering contributions into a single broadcasted sum expression in the AthEM model\n\n# Arguments\n- `sim`::Simulation\n       The simulation object.\n- `athemexcite`::Expr\n               Expression for athermal excitation.\n- `Elecelec`::Union{Expr, Float64}\n            Electron-electron scattering Expr or 0.0 if disabled\n- `Elecphon`::Union{Expr, Float64}\n            Electron-phonon scattering Expr or 0.0 if disabled\n\n# Returns\n- A broadcasted summation of all interaction terms.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.electron_distribution_transport!-Tuple{Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Real}","page":"API","title":"LightMatter.electron_distribution_transport!","text":"electron_distribution_transport!(v_g::Vector{Float64},f::AbstractArray{Float64},Δf::AbstractArray{Float64},dz::Float64)\n\nComputes ballistic transport of an electronic distribution using second-order finite differences via a kinetic like model.\nUses forward(reverse) difference for the boundaries. \n\n# Arguments\n- `v_g`: Group velocity vector or vector of vectors(spatially-resolved DOS)\n- `f`: Distribution function.\n- `Δf`: Output array to store result.\n- `dz`: Spatial resolution.\n\n# Returns\n- In-place change to Δf\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.electron_relaxationtime-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.electron_relaxationtime","text":"electron_relaxationtime(sim::Simulation)\nReturns the requested expression for the electronic relaxation time. \nCurrently implemented: \n- :constant : A constant time defined by sim.athermalelectrons.τ\n- :FLT : Fermi Liquid lifetime defined in https://arxiv.org/abs/2503.09479\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Expression for the athermal electron lifetime due to electron-electron interactions.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.find_relaxeddistribution!-NTuple{5, Any}","page":"API","title":"LightMatter.find_relaxeddistribution!","text":"find_relaxeddistribution(egrid::Vector{Float64},goal::Float64,n::Float64,DOS::spl,kB::Float64)\n\nSolves for a Fermi distribution with the same internal energy as a given target.\n\n# Arguments\n- 'egrid': Energy grid distributions are solved on\n- 'goal': The internal energy of the total electronic system\n- 'n': Float64 of electrons in the thermal system\n- 'DOS': Spline of the density-of-states\n\n# Returns\n- Fermi-Dirac distribution with same internal energy as the goal.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.find_temperatureandμ!-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.find_temperatureandμ!","text":"find_temperatureandμ(Tel::Float64,n::Float64,DOS::spl,egrid::Vector{Float64})\n\nGiven a temperature guess, computes chemical potential and internal energy.\n\n# Arguments\n- 'Tel': Guessed electronic temperature to match the goal\n- 'n': Float64 of electrons in the thermal system\n- 'egrid': Energy grid distributions are solved on\n- 'DOS': Spline of the density-of-states\n\n# Returns\n- Internal energy of the current temperature guess.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.phonon_relaxationtime-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.phonon_relaxationtime","text":"phonon_relaxationtime(sim::Simulation)\n\nDetermines the requested expression for the electron-phonon relaxation time. \nCurrently implemented:\n- :constant : a constant lifetime given by simulation.athermalelectrons.τep\n- :quasi : quasiparticle relaxation time defined in E.Carpene, Phys. Rev. B., 2006, 74, 024301.\n\n# Arguments\n- 'sim': settings of the desired simulation\n\n# Returns\n- Expression for the athermal electron lifetime due to phonon interactions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Density-Matrix","page":"API","title":"Density Matrix","text":"","category":"section"},{"location":"api/#LightMatter.build_dm-Tuple{Any, Any}","page":"API","title":"LightMatter.build_dm","text":"build_dm(N::Int, occ::Vector{Float64})\n\nBuilds a density matrix of NxN states with diagonal occupations occ\n\n# Arguments\n- 'N': Number of states\n- 'occ': Initial occupations of the density matrix \n\n# Returns\n- An assembled density matrix with diagonal given by occ\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.construct_dipolevonNeumann-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.construct_dipolevonNeumann","text":"discretize_DOS(sim::Simulation)\n\nConstructs an expression for the propagation of a Hamiltonian's reaction to light\nin the dipole approximation. It takes the dipole matrix from sim.densitymatrix.DipoleMatrix\n\n# Arguments\n- 'sim': Settings of the simulation containing the dipole matrix and electric fields \n\n# Returns\n- Expression for the propagation of a density matrix under illumination in the dipole approximation\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.discretize_DOS-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.discretize_DOS","text":"discretize_DOS(dos_file::String, no_states::Int, egrid::Vector{Float64})\n\nDiscretizes a DOS and creates a vector of repeating energy states of length no_states.\nThe number of these repeats should mimic the shape of the original DOS. The discretization is \nonly performed along the vector given by egrid. \n\n# Arguments\n- 'dos_file': File path to DOS\n- 'no_states': Approximate length of the final vector (there may be slight differences in the final result)\n- 'egrid': Vector of energy values to discretize the DOS onto \n\n# Returns\n- An approximation of a DOS to use as the diagonal of a Hamiltonian\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.thermal_bath_densitymatrix-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.thermal_bath_densitymatrix","text":"thermal_bath_densitymatrix(H::Matrix{Float64}, β::Float64, ne::Int)\n\nBuilds a thermal density matrix assuming Fermi-Dirac statistics \n\n# Arguments\n- 'H': Hamiltonian of the system, no external forces should be included here\n- 'Β': kB*T in the same units as the Hamiltonian\n- 'ne': The total number of electrons the density matrix represents\n\n# Returns\n- An assembled density matrix with a thermal occupation\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.total_DOS_states-Tuple{Any, Any}","page":"API","title":"LightMatter.total_DOS_states","text":"discretize_DOS(DOS::spl, egrid::Vector{Float64})\n\nCalculates the total number of states within the range of the egrid of the DOS\nprovided by dos_file in discretize_DOS.\n\n# Arguments\n- 'DOS': Spline of the DOS generated from dos_file\n- 'egrid': Vector of energy values to discretize the DOS onto \n\n# Returns\n- Total number of states in the energy window (egrid) of the DOS\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.vonNeumann-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.vonNeumann","text":"vonNeumann(dρ::Matrix{Float64},ρ::Matrix{Float64},H::Matrix{Float64})\n\nEquation of motion for a density matrix\n\n# Arguments\n- 'dρ': In-place derivative of the density matrix\n- 'ρ': Density matrix of the system\n- 'H': Hamiltonian matrix of the system\n\n# Returns\n- In-place function calculating dρ\n\n\n\n\n\n","category":"method"},{"location":"api/#Total-Electronic-Distribution","page":"API","title":"Total Electronic Distribution","text":"","category":"section"},{"location":"api/#LightMatter.FermiDirac-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.FermiDirac","text":"FermiDirac(Tel::Float64, μ::Float64, E::Union{Vector{Float64},Float64}) \n\nReturns the thermal occupation of electrons at a given temperature, chemical potential and energy.\nIf a vector of energies is given then it will return the distribution across that range.\n\n# Arguments\n- 'Tel': Thermal electronic temperature\n- 'μ': Chemical Potential\n- 'E': Energy value or range\n\n# Returns\n- Value or vector of the Fermi-Dirac distribution\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.dFDdE-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.dFDdE","text":"dFDdE(Tel::Float64, μ::Float64, E::Union{Vector{Float64},Float64})\n\nReturns the change in the Fermi distribution with respect to energy at the given energy value or range.\n\n# Arguments\n- 'Tel': Thermal electronic temperature\n- 'μ': Chemical Potential\n- 'E': Energy value or range\n\n# Returns\n- Value or vector of the partial derivative of the Fermi distribution with respect to energy\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.dFDdT-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.dFDdT","text":"dFDdT(Tel::Float64, μ::Float64, E::Union{Vector{Float64},Float64})\n\nReturns the change in the Fermi distribution with respect to temperature at the given energy value or range.\n\n# Arguments\n- 'Tel': Thermal electronic temperature\n- 'μ': Chemical Potential\n- 'E': Energy value or range\n\n# Returns\n- Value or vector of the partial derivative of the Fermi distribution with respect to temperature\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.dFDdμ-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.dFDdμ","text":"dFDdμ(Tel::Float64, μ::Float64, E::Union{Vector{Float64},Float64})\n\nReturns the change in the Fermi distribution with respect to chemical potential at the given energy value or range.\n\n# Arguments\n- 'Tel': Thermal electronic temperature\n- 'μ': Chemical Potential\n- 'E': Energy value or range\n\n# Returns\n- Value or vector of the partial derivative of the Fermi distribution with respect to chemical potential\n\n\n\n\n\n","category":"method"},{"location":"api/#Thermal-Electron-Bath","page":"API","title":"Thermal Electron Bath","text":"","category":"section"},{"location":"api/#LightMatter.athem_electempenergychange-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.athem_electempenergychange","text":"athem_electempenergychange(sim::Simulation)\n\nBuilds an expression for the change in internal energy of an AthEM electronic bath\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Expression for the change of internal energy of an AthEM electronic bath\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_athemelectron-Tuple{Expr}","page":"API","title":"LightMatter.build_athemelectron","text":"build_athemelectron(Δu::Expr)\n\nBuilds the differential equation (expression) for an AthEM thermal bath. The difference to the TTM\nis due to accounting for the changing particle number\n\n# Arguments\n- 'Δu': Expression for the change in internal energy of the electronic bath\n\n# Returns\n- Expression for the time evolution of a, AthEM electronic temperature\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_electronTTM-Tuple{LightMatter.Simulation, Expr, Expr, Expr}","page":"API","title":"LightMatter.build_electronTTM","text":"build_electronTTM(sim::Simulation, Source::Expr, ElecPhon::Expr, HeatCapacity::Expr)\n\nBuilds the differential equation (expression) for a Two-Temperature like system.\n\n# Arguments\n- 'sim': Simulation settings and parameters\n- 'Source': Expression for the incoming energy source (typically a laser)\n- 'ElecPhon': Expression for the electron-phonon coupling\n- 'HeatCapacity': Expression for calculating the heat capacity\n\n# Returns\n- Expression for the time evolution of a two-temperature model electronic temperature\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.depthderivative!-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.depthderivative!","text":"depthderivative!(vec::Vector{Float64}, dz::Float64, Diff::Vector{Float64})\n\nCalculates a 2nd order finite difference method of a vector along a grid with spacing dz.\nUses central difference in the middle and forward(reverse) difference at the top(end) of the vector\n\n# Arguments\n- 'vec': Vector the finite difference is being performed over\n- 'dz': z-grid spacing\n- 'Diff': Vector to store the finite difference result\n\n# Returns\n- Updates the diff vector with the finite difference result\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.elec_energychange-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.elec_energychange","text":"elec_energychange(egrid::Vector{Float64}, relax_dis::Vector{Float64}, DOS::spl)\n\nCalculates the energy change of the thermal bath due to non-equilibrium-equilibrium\nelectron scattering.\n\n# Arguments\n- 'egrid: Energy grid the simulation is solved over\n- 'relax_dis': The change in distribution due to the electron-electron scattering\n- 'DOS': Density-of-states of the system\n\n# Returns\n- The change in the internal energy of the thermal system due to e-e scattering\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.electronphonon_coupling-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.electronphonon_coupling","text":"electronphonon_coupling(sim::Simulation)\n\nDetermines the expression for the coupling between an electronic and phononic thermal bath.\nCurrently implemented:\n- :variable : Calculates the electron-phonon coupling parameter from the density-of-states of the system\n- :constant : Uses a constant value for the electron-phonon coupling parameter (g)\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Expression for the electron-phonon thermal bath energy transfer\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.electrontemperature_conductivity!-NTuple{5, Any}","page":"API","title":"LightMatter.electrontemperature_conductivity!","text":"electrontemperature_conductivity!(Tel::Vector{Float64}, κ::Union{Float64,Vector{Float64}}, dz::Float64, Tph::Vector{Float64}, cond::Vector{Float64})\n\nCalculates the change in temperature due to diffusive transport of energy through the system. Uses the boundary conditions of\nsetting dTel / dz to 0.0.\n\n# Arguments\n- 'Tel': Temperature of the electronic bath\n- 'κ': Electronic thermal conductivity at room temperature\n- 'dz': z-grid spacing\n- 'Tph': Temperature of the phonon bath\n- 'cond': Vector to store the change in electronic temperature\n\n# Returns\n- Updates the cond vector with the change in electronic temperature at each grid point\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.electrontemperature_factory-Tuple{LightMatter.Simulation, Expr}","page":"API","title":"LightMatter.electrontemperature_factory","text":"electrontemperature_factory(sim::Simulation, laser::Expr)\n\nAssembles expresssion for how the electronic temperature should be propgated through time.\n\n# Arguments\n- 'sim': Simulation settings and parameters\n- 'laser': Expression for laser energy as a funciton of time\n\n# Returns\n- Expression for the time-propagation of the electronic temperature subsystem\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.electrontemperature_heatcapacity-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.electrontemperature_heatcapacity","text":"electrontemperature_heatcapacity(sim::Simulation)\n\nDetermines the expression for the electronic temperature's heat capacity.\nCurrently implemented:\n- :linear : Specific heat of electrons(γ) multiplied by the current temperature\n- :nonlinear : Calculated from the density-of-states of the system\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Expression for the electronic temperature's heat capacity\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.nonlinear_electronheatcapacity-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.nonlinear_electronheatcapacity","text":"nonlinear_electronheatcapacity(Tel::Float64, μ::Float64, DOS::spl, egrid::Vector{Float64})\n\nCalculates non-linear electronic bath heat capacity. A more accurate method than the\nlinear form.\n\n# Arguments\n- 'Tel': Temperature of the electronic bath\n- 'μ': Chemical potential of the electronic bath\n- 'DOS': Density-of-states of the system\n- 'egrid': Energy grid the simulation is solved over\n\n# Returns\n- The current heat capacity of the electronic thermal bath\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.variable_electronphononcoupling-NTuple{6, Any}","page":"API","title":"LightMatter.variable_electronphononcoupling","text":"variable_electronphononcoupling(λ::Float64, ω::Float64, DOS::spl, Tel::Float64, μ::Float64, Tph::Float64, egrid::Vector{Float64})\n\nCalculates the non-linear electron phonon coupling parameter and subsequent energy flow from the density-of-states\nof the system. More accurate than a constant value. \nThe expression can be found in Z. Lin, L. V. Zhigilei and V. Celli, Phys. Rev. B, 2008, 77, 075133.\n\n# Arguments\n- 'λ': Electron-phonon mass enhancement parameter\n- 'ω': Second moment of the phonon spectrum\n- 'DOS': Density-of-states of the system\n- 'Tel': Temperature of the electronic bath\n- 'μ': Chemical potential of the electronic bath\n- 'Tph': Temperature of the phonon bath\n- 'egrid': Energy grid the simulation is solved over\n\n# Returns\n- Energy flow between an electronic and phononic bath with a calculate g parameter\n\n\n\n\n\n","category":"method"},{"location":"api/#Lasers","page":"API","title":"Lasers","text":"","category":"section"},{"location":"api/#LightMatter.E_magnitude-Tuple{Any, Any}","page":"API","title":"LightMatter.E_magnitude","text":"E_magnitude(las_field::Vector{Expr}, ext_field::Vector{Expr})\n\n# Arguments\n- 'las_field': Electric field vector from the laser\n- 'ext_field': Electric field vector from external sources\n\n# Returns\n- Expression for the total magntitude of electric fields\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.get_laser_fields-Tuple{Any}","page":"API","title":"LightMatter.get_laser_fields","text":"get_laser_fields(las::Laser)\n\nReturns an expression for the electric field induced by the laser\nCurrently implemented:\n- :Gaussian\n- :Rectangular\n\n# Arguments\n- 'las': Laser settings \n\n# Returns\n- Expression for the electric field of the laser\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.laser_factory-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.laser_factory","text":"laser_factory(sim::Simulation)\n\nAssembles the user desired laser expression\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Expression for the power of the laser as a function of time and depth\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.photon_energytofrequency-Tuple{Any}","page":"API","title":"LightMatter.photon_energytofrequency","text":"photon_energytofrequency(hv::Real)\n\n# Arguments\n- 'hv': Photon energy in eV\n\n# Returns\n- Photon frequency in 1 / fs\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.spatial_laser-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.spatial_laser","text":"spatial_laser(sim::Simulation)\n\nAssembles the expression for the laser penetration depth. Currently only works in the z-axis\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Expression for the spatial shape of the laser\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.spatial_xy_laser-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.spatial_xy_laser","text":"WIP: spatial_xy_laser(sim::Simulation)\n\nDefines how the laser energy changes with distance from the spot centre. Do not use as simulations\naren't constructed for more than 1D.\n\nCurrently implemented:\n- :Cylindrical : Circular shaped sample\n- :Cubic : Cubic shaped sample\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Expression for the spatial shape of the laser in the xy plane\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.spatial_z_laser-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.spatial_z_laser","text":"spatial_z_laser(sim::Simulation)\n\nDefines how the laser energy changes with depth into the sample\nCurrently implemented:\n- :ballistic : Ballistic depth of electrons defines spatial change, controlled by δb\n- :optical : Absorbtion depth of the laser controls the spatial change, controlled by ϵ (1/α)\n- :combined : Both ballistic and optical parameters enabled, sums the two effects together\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Expression for the spatial shape of the laser\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.temporal_laser-Tuple{Laser}","page":"API","title":"LightMatter.temporal_laser","text":"temporal_laser(las::Laser)\n\nAssembles the expression for the user desired temporal shape of the laser\nCurrently implemented:\n- :Gaussian : Gaussian laser shape\n- :Lorentzian : Lorentzian laser shape\n- :HyperbolicSecant : Hyperbolic secant laser shape\n- :Rectangular : Constant illumination style method. The laser is on for 2*FWHM at either side of 0.0 fs\n\n# Arguments\n- 'las': Settings and parameters of the laser\n\n# Returns\n- Expression for the temporal shape of the laser\n\n\n\n\n\n","category":"method"},{"location":"api/#Phononic-Distribution","page":"API","title":"Phononic Distribution","text":"","category":"section"},{"location":"api/#Thermal-Phonon-Bath","page":"API","title":"Thermal Phonon Bath","text":"","category":"section"},{"location":"api/#LightMatter.build_phonontemperature-Tuple{LightMatter.Simulation, Union{Float64, Expr}, Expr, Expr}","page":"API","title":"LightMatter.build_phonontemperature","text":"build_phonontemperature(sim::Simulation, Source::Expr, ElecPhon::Expr, HeatCapacity::Expr)\n\nBuilds the differential equation (expression) for the phonon bath\n\n# Arguments\n- 'sim': Simulation settings and parameters\n- 'Source': Expression for energy input from athermal electrons\n- 'ElecPhon': Expression for the thermal electron-phonon coupling\n- 'HeatCapacity': Expression for calculating the heat capacity\n\n# Returns\n- Expression for the time evolution of a phnonic thermal bath\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.neqelectron_phonontransfer-NTuple{4, Any}","page":"API","title":"LightMatter.neqelectron_phonontransfer","text":"neqelectron_phonontransfer(fneq::Vector{Float64}, egrid::Vector{Float64}, τep::Float64, DOS::spl)\n\nCalculates energy input into the phonon bath due to non-equilibrium electron-phonon scattering\n\n# Arguments\n- 'fneq': Non-equilibrium electron distribution\n- 'egrid': Energy grid the distributions are solved on\n- 'τep': Lifetime of athermal electrons due to electron-phonon scattering\n- 'DOS': Density-of-states of the system\n\n# Returns\n- Value of the change in the phonon internal energy\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.phonontemperature_conductivity!-NTuple{4, Any}","page":"API","title":"LightMatter.phonontemperature_conductivity!","text":"phonontemperature_conductivity!(Tph::Vector{Float64}, κ::Union{Float64,Vector{Float64}}, dz::Float64, cond::Vector{Float64})\n\nCalculates thermal phonon conductivity due to diffusive transport\n\n# Arguments\n- 'Tph': Phonon bath temperature\n- 'κ': Phonon thermal conductivity (assumed constant)\n- 'dz': Spacing of the spatial grid\n- 'cond': Vector to store the temperature change\n\n# Returns\n- Updates cond with the change in temperature at each z-grid point\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.phonontemperature_factory-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.phonontemperature_factory","text":"phonontemperature_factory(sim::Simulation)\n\nAssembles expresssion for how the phononic temperature should be propgated through time.\n\n# Arguments\n- 'sim': Simulation settings and parameters\n# Returns\n- Expression for the time-propagation of the phononic temperature subsystem\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.phonontemperature_heatcapacity-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.phonontemperature_heatcapacity","text":"phonontemperature_heatcapacity(sim::Simulation)\n\nDetermines the expression for the phononic temperature's heat capacity.\nCurrently implemented:\n- :constant : Constant phonon heat capacity (Cph)\n- :variable : Calculated from Simpson's rule\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Expression for the phononic temperature's heat capacity\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.phonontemperature_source-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.phonontemperature_source","text":"phonontemperature_source(sim::Simulation)\n\nDetermines the expresision of any additional source terms into the phonon bath. Currently this\nis just athermal electron-phonon coupling\nCurrently implemented:\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Expression for any source term into the phonon bath\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.variable_phononheatcapacity-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.variable_phononheatcapacity","text":"variable_phononheatcapacity(Tph::Float64, n::Float64, θ::Float64)\n\nCalculates non-linear phononic bath heat capacity. A more accurate method than the\nconstant form.\n\n# Arguments\n- 'Tph': Temperature of the phononic bath\n- 'n': Float64 of atoms per nm³\n- 'θ': Debye temperature of the system\n\n# Returns\n- The current heat capacity of the phononic thermal bath\n\n\n\n\n\n","category":"method"},{"location":"api/#Property-Calculation","page":"API","title":"Property Calculation","text":"","category":"section"},{"location":"api/#LightMatter.Bode_rule-Tuple{Any, Any}","page":"API","title":"LightMatter.Bode_rule","text":"Bode_rule(y::Vector{Float64}, x::Vector{Float64})\n\nPerforms numerical integration on a grid using the higher order Boole's method.\nWill integrate from end to end of the x vector\n\n# Arguments\n- 'y': The spectrum on a grid to be integrated\n- 'x': The grid the spectrum is on w\n\n# Returns\n- The integration value across the range\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.c_T-NTuple{4, Any}","page":"API","title":"LightMatter.c_T","text":"c_T(μ::Float64, Tel::Float64, DOS::spl, egrid::Vector{Float64})\n\nCalculates the change in internal energy of a Fermi Dirac distribution with respect to temperature\n\n# Arguments\n- 'μ': Electronic distribution\n- 'Tel': The electronic bath temperature\n- 'DOS': Density-of-states of the system\n- 'egrid': Energy grid the simulation is solved over\n\n# Returns\n- The value of dU/dT\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.c_μ-NTuple{4, Any}","page":"API","title":"LightMatter.c_μ","text":"c_μ(μ::Float64, Tel::Float64, DOS::spl, egrid::Vector{Float64})\n\nCalculates the change in internal energy of a Fermi Dirac distribution with respect to chemical potential\n\n# Arguments\n- 'μ': Electronic distribution\n- 'Tel': The electronic bath temperature\n- 'DOS': Density-of-states of the system\n- 'egrid': Energy grid the simulation is solved over\n\n# Returns\n- The value of dU/dμ\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.find_chemicalpotential-NTuple{4, Any}","page":"API","title":"LightMatter.find_chemicalpotential","text":"find_chemicalpotential(no_part::Float64, Tel::Float64, DOS::spl, egrid::Vector{Float64})\n\nDetermines the chemical potential at the current temperature\n\n# Arguments\n- 'no_part': Float64 of particles in the thermal electronic system\n- 'Tel': Temperature of the electronic bath\n- 'DOS': Density-of-states of the system\n- 'egrid': Energy grid the simulation is solved over\n\n# Returns\n- The value of the chemical potential\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.get_internalenergy-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.get_internalenergy","text":"get_internalenergy(Dis::Vector{Float64}, DOS::spl, egrid::Vector{Float64})\n\nCalculates the internal energy of the given electronic distribution\n\n# Arguments\n- 'Dis': Electronic distribution\n- 'DOS': Density-of-states of the system\n- 'egrid': Energy grid the simulation is solved over\n\n# Returns\n- The internal energy of the given distribution\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.get_noparticles-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.get_noparticles","text":"get_noparticles(Dis::Vector{Float64}, DOS::spl, egrid::Vector{Float64})\n\nCalculates number of electrons in the given distribution\n\n# Arguments\n- 'Dis': Electronic distribution\n- 'DOS': Density-of-states of the system\n- 'egrid': Energy grid the simulation is solved over\n\n# Returns\n- The number of electrons\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.get_thermalparticles-NTuple{4, Any}","page":"API","title":"LightMatter.get_thermalparticles","text":"get_thermalparticles(μ::Float64, Tel::Float64, DOS::spl, egrid::Vector{Float64})\n\nCalculates number of electrons assuming a Fermi Dirac distribution\n\n# Arguments\n- 'μ': Chemical potential\n- 'Tel': Temperature of the electronic bath\n- 'DOS': Density-of-states of the system\n- 'egrid': Energy grid the simulation is solved over\n\n# Returns\n- The number of electrons\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.p_T-NTuple{4, Any}","page":"API","title":"LightMatter.p_T","text":"p_T(μ::Float64, Tel::Float64, DOS::spl, egrid::Vector{Float64})\n\nCalculates the change in the number of particles of a Fermi Dirac distribution with respect to temperature\n\n# Arguments\n- 'μ': Electronic distribution\n- 'Tel': The electronic bath temperature\n- 'DOS': Density-of-states of the system\n- 'egrid': Energy grid the simulation is solved over\n\n# Returns\n- The value of dn/dT\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.p_μ-NTuple{4, Any}","page":"API","title":"LightMatter.p_μ","text":"p_μ(μ::Float64, Tel::Float64, DOS::spl, egrid::Vector{Float64})\n\nCalculates the change in the number of particles of a Fermi Dirac distribution with respect to chemical potential\n\n# Arguments\n- 'μ': Electronic distribution\n- 'Tel': The electronic bath temperature\n- 'DOS': Density-of-states of the system\n- 'egrid': Energy grid the simulation is solved over\n\n# Returns\n- The value of dn/dμ\n\n\n\n\n\n","category":"method"},{"location":"api/#Running-Dynamics","page":"API","title":"Running Dynamics","text":"","category":"section"},{"location":"api/#LightMatter.run_simulation-Tuple{LightMatter.Simulation, Dict{String, Float64}, Tuple{Float64, Float64}}","page":"API","title":"LightMatter.run_simulation","text":"run_simulation(sys::Dict{String,Union{Expr,Vector{Expr}}}, initialtemps::Dict{String, Float64},\ntspan::Tuple{Float64,Float64}, sim::Simulation; \nsave, tolerance, max_step, min_step, callbacks)\n\nGenerates the problem the dynamics will solve and then solves the coupled system of ODE's.\nCurrently always uses Tsit5 for the integration routine but in the future that may be user-defined\n\n# Arguments\n- 'sys': Dictionary of ODE equations to be propagated\n- 'initialtemps': Dictionary of initial temperatures of the bath\n- 'tspan': Tuple of values for the dynamics to run between (the laser is centred on 0.0)\n- 'sim': Simulation settings and parameters\n\n# KWARGS\n- Any key-word arguemnts from DiffEq that work with ODEProblems can be including in a namedtuple here\n\n# Returns\n- The solution of the dynamics calculation\n\n\n\n\n\n","category":"method"},{"location":"api/#Outputting","page":"API","title":"Outputting","text":"","category":"section"},{"location":"api/#LightMatter.convert_symbols_to_strings-Tuple{Any}","page":"API","title":"LightMatter.convert_symbols_to_strings","text":"convert_symbols_to_strings(dict::Dict{Any,Any})\n\nConverts any Symbol key values to their respecitve string for saving\n\n# Arguments\n- 'dict': The dictionary which needs keys converting\n\n# Returns\n- Dictionary with all Symbol keys changed to strings\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.create_datafile_and_structure-Tuple{String}","page":"API","title":"LightMatter.create_datafile_and_structure","text":"create_datafile_and_structure(file_name::String)\n\nCreates a file with the standard data structure:\n- Athermal Electrons\n- Density Matrix\n- Electronic Temperature\n- Phononic Temperature\n- Electronic Distribution\n- Phononic Distribution\n- Laser\n- Structure\n\n# Arguments\n- 'file_name': The name the user wishes the file to be saved as \n\n# Returns\n- A created HDF5 file\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.dict_to_hdf5-Tuple{Any, Any}","page":"API","title":"LightMatter.dict_to_hdf5","text":"dict_to_hdf5(f,d::Dict{String,Any})\n\nUnpacks a dictionary and saves it to the designated file location (f)\n\n# Arguments\n- 'f': Location in the HDF5 file the dictionary information will be saved to\n- 'd': The dictionary to be unpacked and saved\n\n# Returns\n- Nothing returned but dictionary saved to location\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.extract_structure-Tuple{Any, Structure}","page":"API","title":"LightMatter.extract_structure","text":"extract_structure(f, structure::Structure)\n\nSpecific way of writing structure settings to the file as both DOS and Dimension need special handling\n\n# Arguments\n- 'f': File to be written to\n- 'structure': Structure settings and parameters\n\n# Returns\n- Nothing returned but structure parameters and settings wrote to file\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.generate_valuedict-Tuple{Any, LightMatter.Simulation, Any}","page":"API","title":"LightMatter.generate_valuedict","text":"generate_valuedict(sol, sim::Simulation, fields::Vector{Symbol})\n\nGenerates a dictionary of all propagated systems with placeholder arrays\n\n# Arguments\n- 'sol': The solution of the simulation\n- 'sim': Simulation settings and parameters\n- 'fields': Symbolic name of the propgated subsystems\n\n# Returns\n- Dictionary of values of each of the propgated subsystems\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.particlenumber_values-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.particlenumber_values","text":"particlenumber_values(sim::Simulation)\n\nCalculates the number of thermal electrons for a system when not propagated\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Array of the number of thermal electrons at each spatial point\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.populate_unpropagatedvalues!-Tuple{Dict{String, Float64}, Any, LightMatter.Simulation, Any}","page":"API","title":"LightMatter.populate_unpropagatedvalues!","text":"populate_unpropagatedvalues!(sol, initial_temps::Dict{String,Float64}, fields::Vector{Symbol}, sim::Simulation, vals::Dict{String,AbstractArray{Float64}})\n\nAdds placeholder information to any unpropagated fields\n\n# Arguments\n- 'sol': The solution of the simulation\n- 'initial_temps': Initial temperature the baths have been set to\n- 'sim': Simulation settings and parameters\n- 'fields': Symbolic name of the propgated subsystems\n- 'vals': Dictionary of the propgated subsytems with placeholder arrays\n\n# Returns\n- vals dictionary with the added unpropagated subsystems\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.populate_value_dict!-Tuple{Any, Any, Any}","page":"API","title":"LightMatter.populate_value_dict!","text":"populate_value_dict!(sol ,fields::Vector{Symbol}, vals::Dict{String,AbstractArray{Float64}})\n\nPopulates the subsystem dictionary with the reuslting vlaues from the simulation\n\n# Arguments\n- 'sol': The solution of the simulation\n- 'fields': Symbolic name of the propgated subsystems\n- 'vals': Dictionary of the propgated subsytems with placeholder arrays\n\n# Returns\n- The vals dictionary with the actual results inside\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.post_production-Tuple{Any, String, Dict{String, Float64}, Vector{Symbol}, LightMatter.Simulation}","page":"API","title":"LightMatter.post_production","text":"post_production(sol,file_name::String,initial_temps::Dict{String,Float64},output::Symbol,sim::Simulation)\n\nHandles processing, saving the simulation after it has completed. Uses HDF5 file format\nCurrently the only output setting supported is :minimum which only saves the parameters, chemical potential and\nprogated systems\n\n# Arguments\n- 'sol': The solution of the simulation\n- 'file_name': The name the user wishes the file to be saved as \n- 'initial_temps': Initial temperature the baths have been set to\n- 'output': The output method required - may change in future\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Nothing is returned but a file is created\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.seperate_results-Tuple{Any, Dict{String, Float64}, LightMatter.Simulation}","page":"API","title":"LightMatter.seperate_results","text":"seperate_results(sol, initial_temps::Dict{String,Float64}, sim::Simulation)\n\nSeperates the results held inside of the solution object\nAlso fills all unpropagated subsystems with parameter/temp information where neccessary\n\n# Arguments\n- 'sol': The solution of the simulation\n- 'initial_temps': Initial temperature the baths have been set to\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Dictionary of values of each of the seperated systems\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.write_DOS-Tuple{Structure}","page":"API","title":"LightMatter.write_DOS","text":"write_DOS(structure::Structure)\n\nHandles converting the DOS splines into a writable format\n\n# Arguments\n- 'structure': Structure settings and parameters\n\n# Returns\n- Dictionary of the DOS\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.write_simulation-Tuple{Any, LightMatter.Simulation}","page":"API","title":"LightMatter.write_simulation","text":"write_simulation(f,sim::Simulation)\n\nWrites all settings and parameters to their respective location in the file (f)\n\n# Arguments\n- 'f': File to be written to\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Nothing returned but all parameters and settings wrote to file\n\n\n\n\n\n","category":"method"},{"location":"api/#DOS-/-Geometry-Functions","page":"API","title":"DOS / Geometry Functions","text":"","category":"section"},{"location":"api/#LightMatter.DOSScale!-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}}","page":"API","title":"LightMatter.DOSScale!","text":"DOSScale!(Temp::Matrix{Float64},bulk::Vector{Float64},Energies::Vector{Float64})\n\nEnsures that all DOS are scaled to the same number of particles as the bulk\n\n# Arguments\n- 'Temp': Matrix of number of states in height X Energy\n- 'bulk': The bulk DOS on the same energy grid as Temp\n- 'Energies': The energy grid used for Temp and bulk\n\n# Returns\n- Temp with the rescaled DOS'\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.DOS_initialization-Tuple{Union{Nothing, String, Vector{String}}, Union{Nothing, String, Vector{String}}, Union{Nothing, String}, Union{Nothing, String}, Float64, LightMatter.Dimension, Bool, Union{Nothing, Interpolations.AbstractExtrapolation}}","page":"API","title":"LightMatter.DOS_initialization","text":"DOS_initialization(bulk_DOS::Union{String,Vector{String}}, bulk_geometry::String, DOS_folder::String, slab_geometry::String,\n                   atomic_layer_tolerance::Float64, dimension::Dimension, zDOS::Bool, DOS::Union{Nothing, spl})\n\nDetermines the desired DOS configuration and assembles it accordingly\n\n# Arguments\n- 'bulk_DOS': The bulk DOS file location\n- 'bulk_geometry': The bulk DOS geometry location\n- 'DOS_folder': The folder where the atom-projected DOS' are present\n- 'slab_geometry': The geometry.in file used in the creation of the atom-projected DOS'\n- 'atomic_layer_tolerance': The minimum height 2 atoms need to be apart to be considered seperate layers (default = 0.1 nm)\n- 'dim': The Dimension struct which holds the z-grid\n- 'zDOS': Bool for enabling a spatially dependent DOS\n' 'DOS': Allows the user to use their own splined DOS, for other regions of the code it must be the same type as normal DOS\n\n# Returns\n- A spline or vector of splines for the desired DOS structure\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_DOS-Tuple{String, String}","page":"API","title":"LightMatter.build_DOS","text":"build_DOS(dos_file::String, geometry_file::String)\n\nA convenient constructor for building a DOS from the DOS and geometry file.\n\n# Arguments\n- 'dos_file': Path to the total DOS file.\n- 'geometry_file': Path to the geometry.in file\n\n# Returns\n- An interpolation object representing the DOS.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_group_velocity-Tuple{Union{Nothing, Vector{Float64}}, Union{Float64, Vector{Float64}}, Bool, Symbol, Structure}","page":"API","title":"LightMatter.build_group_velocity","text":"build_group_velocity(v_g::Union{Vector{Float64},Nothing}, FE::Union{Float64,Vector{Float64}}, Conductivity::Bool, conductive_velocity::Symbol, structure::Structure)\n\nCreates a vector or array of vectors (spatial DOS) for the group veolcity for ballistic electron transport. Users can also provide a constant value in the form\nof v_g, they must also set conductive_veolcity to constant.\nCurrently Implemented:\n- :fermigas : Assumes a free electron gas solution therefore is an analytical form of the group velocity\n- :effectiveoneband : Uses the effective one band model to convert a DOS into a group velocity, for more details see Mueller & Rethfeld, Phys. Rev. B 87, 035139.\n- :constant : Uses the v_g argument to set a constant group velocity for all energy ranges\n\n# Arguments\n- 'v_g': A constant group velocity value if :constant is requested\n- 'FE': The Fermi energy, calculated from get_FermiEnergy\n- 'Conductivity': Sets whether ballistic transport should be enabled\n- 'conductive_velocity': The form the user wants the group velocity to take\n- 'structure': Contains all structural information including DOS and number of elemental systems\n\n# Returns\n- The group velocity vector or array of vectors as requested by the user for ballistic electron transport\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_zDOSArray-Tuple{Vector{Float64}, String, Vector{String}, Vector{Float64}}","page":"API","title":"LightMatter.build_zDOSArray","text":"build_zDOSArray(egrid::Vector{Float64},folder::String,files::Vector{String},heights::Vector{Float64})\n\nBuilds a matrix of the DOS as a function of height and energy for the individual layers. \n\n# Arguments\n- 'egrid': Energy grid the DOS is calculated on\n- 'folder': The folder where the atom-projected DOS' are present\n- 'files': Vector of file names \n- 'heights': Vector of each file names height\n\n# Returns\n- A matrix of states as a function of height and energy\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.effective_one_band_velocity-Tuple{DataInterpolations.AkimaInterpolation, Interpolations.AbstractExtrapolation, Vector{Float64}, Float64}","page":"API","title":"LightMatter.effective_one_band_velocity","text":"effective_one_band_velocity(DOS::spl, egrid::Vector{Float64}, FE::Float64)\n\nCalculates the group velocity from the effective one band model.\nFor more details see Mueller & Rethfeld, Phys. Rev. B 87, 035139.\n\n# Arguments\n- 'DOS': The density-of-states of the system\n- 'egrid': Energy grid all distributions are solved on\n- 'FE': The Fermi energy, calculated from get_FermiEnergy\n\n# Returns\n- The effective one band model group velocity as a vector or vector of vectors depending on the structure\nof the system\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.effective_onebandmodel-Tuple{Any, Vector{Float64}, Float64}","page":"API","title":"LightMatter.effective_onebandmodel","text":"effective_onebandmodel(DOS::spl, egrid::Vector{Float64}, FE::Float64)\n\nCalculates the dispersion relation within the effective one band model.\nFor more details see Mueller & Rethfeld, Phys. Rev. B 87, 035139.\n\n# Arguments\n- 'DOS': The density-of-states of the system\n- 'egrid': Energy grid all distributions are solved on\n- 'FE': The Fermi energy, calculated from get_FermiEnergy\n\n# Returns\n- The effective one band model dispersion relation\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.generate_DOS-Tuple{String, Float64}","page":"API","title":"LightMatter.generate_DOS","text":"generate_DOS(File::String, unit_scalar::Float64)\n\nGenerates a spline of a DOS from a file. Assumes the structure of the DOS is column 1 is Energy in eV\nand column 2 is States in eV⁻¹V⁻¹ (volume of unit cell) \n\n# Arguments\n- 'File': Path to the total DOS file.\n- 'unit_scalar': Scalar to convert the units (1/V in nm⁻³).\n\n# Returns\n- An interpolation object representing the DOS.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.get_FermiEnergy-Tuple{String}","page":"API","title":"LightMatter.get_FermiEnergy","text":"get_FermiEnergy(File::String)\n\nCalculates the Fermi energy defined as the difference between 0.0 and the\nbottom of the valence band. Assumes the DOS provided has the Fermi energy\nset to 0.0.\n\n# Arguments\n- 'File': Path to a file containing the density of states data.\n\n# Returns\n- The Fermi energy calculated at the bottom of the valence band.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.get_atomiclayers-Tuple{Matrix{Float64}, Float64}","page":"API","title":"LightMatter.get_atomiclayers","text":"get_atomiclayers(atoms::Matrix{Float64},tolerance::Float64)\n\nSeperats the atoms into their layers and selects a single atom from each layer. To remove degeneracy for \nlarger supercell structures.\n\n# Arguments\n- 'atoms': Matrix of the atom number and it's repseictve coordinates\n- 'tolerance': The minimum height 2 atoms need to be apart to be considered seperate layers (default = 0.1Å)\n\n# Returns\n- A trimmed matrix of atoms now containing one atom per layer\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.get_fermigas_dos-Tuple{Vector{Float64}, Float64}","page":"API","title":"LightMatter.get_fermigas_dos","text":"get_fermigas_dos(egrid, FE)\n\nFunction for calculating a free electron gas.\n\n# Arguments\n- 'egrid': Energy grid all distributions are solved on\n- 'FE': The Fermi energy, calculated from get_FermiEnergy\n\n# Returns\n- The free electron gas denisty-of-states\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.get_fermigas_velocity-Tuple{Vector{Float64}, Float64}","page":"API","title":"LightMatter.get_fermigas_velocity","text":"get_fermigas_velocity(egrid::Vector{Float64}, EF::Float64)\n\nThe analytical free electron gas group velocity, requested by conductive_velocity = :fermigas\n\n# Arguments\n- 'egrid': Energy grid all distributions are solved on\n- 'FE': The Fermi energy, calculated from get_FermiEnergy\n\n# Returns\n- The free electron gas group velocity\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.get_files_heights_forDOS-Tuple{String, String, Float64}","page":"API","title":"LightMatter.get_files_heights_forDOS","text":"get_files_heights_forDOS(folder::String,geometry::String,tolerance::Float64)\n\nExtracts atom from geometry, removes all bar one from each layer defined by tolerance, then connects the atom\nto the corresponding file in the folder of DOS'. Readjusts the heights to set the top layer to 0.0 and the\nlower layers to increase from there. \n\n# Arguments\n- 'folder': The folder where the atom-projected DOS' are present\n- 'geometry': The geometry.in file used in the creation of the atom-projected DOS'\n- 'tolerance': The minimum height 2 atoms need to be apart to be considered seperate layers (default = 0.1Å)\n\n# Returns\n- A vector of DOS files and their respective heights\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.get_interpolant-Tuple{Any, Any}","page":"API","title":"LightMatter.get_interpolant","text":"get_interpolant(xvals::Vector{Float64},yvals::Vector{Float64})\n\nGenerates a linear spline of any two vectors with a constant extrapolation applied to the boundaries.\n\n# Arguments\n- 'xvals': x-axis of the desired spline\n- 'yvals': y-axis of the desired spline\n\n# Returns\n- Spline of yvals vs xvals\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.get_slabgeometry-Tuple{String}","page":"API","title":"LightMatter.get_slabgeometry","text":"get_slabgeometry(file_path::String)\n\nExtracts the atoms and their coordinates from a FHI-aims slab geometry.in file. It ignores any \natoms that have their relaxation constrained. \n\n# Arguments\n- 'file_path': The geometry.in file used in the creation of the atom-projected DOS'\n\n# Returns\n- A matrix of the atom number and their coordinates\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.get_unitcellvolume-Tuple{String}","page":"API","title":"LightMatter.get_unitcellvolume","text":"get_unitcellvolume(geometry_file::String)\n\nCalculates the volume of the unit cell for DOS unit conversion\n\n# Arguments\n- 'geometry_file': Path to the geometry.in file\n\n# Returns\n- Volume of the unit cell in nm⁻³\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.spatial_DOS-Tuple{String, String, String, Float64, LightMatter.Dimension, Float64}","page":"API","title":"LightMatter.spatial_DOS","text":"spatial_DOS(folder::String,geometry::String,bulk::String,Vbulk::Float64,dim::Dimension,tolerance::Float64)\n\nCreates a spline of a DOS at each z-grid point in the simulation. Reads a folder of atom projected DOS's and the \nrespective geomwtry.in file to determine the height of each DOS and interpolates between them to create the final\nDOS'\n\n# Arguments\n- 'folder': The folder where the atom-projected DOS' are present\n- 'geometry': The geometry.in file used in the creation of the atom-projected DOS'\n- 'bulk': The bulk DOS file location\n- 'Vbulk': The volume of the bulk unit cell\n- 'dim': The Dimension struct which holds the z-grid\n- 'tolerance': The minimum height 2 atoms need to be apart to be considered seperate layers (default = 0.1 nm)\n\n# Returns\n- A vector of splines corresponding to the DOS at each z-height\n\n\n\n\n\n","category":"method"},{"location":"api/#Unit-Handling","page":"API","title":"Unit Handling","text":"","category":"section"},{"location":"api/#LightMatter.convert_units-Tuple{Unitful.FreeUnits, Any}","page":"API","title":"LightMatter.convert_units","text":"convert_units(value::Union{Quantity, AbstractArray{<:Quantity}, Float64, AbstractArray{Float64}})\n\nConverts any user-given parameters that they have attached units to, to the correct units for LightMatter.jl\nAll values without Unitful.jl units attached are assumed to be in the correct units given by LightMatter_units\n\n# Arguments\n- 'value': The value(array of values) of the parameter, either as a Unitful.jl Quantity or a Float64\n\n# Returns\n- The Quantity converted into LightMatter.jl's preferred units, or the Float64 left as is\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.BaseUnits","page":"API","title":"LightMatter.BaseUnits","text":"BaseUnits = \n\nGlobal Tuple for conversion factors from base SI units to base LightMatter units\n\n\n\n\n\n","category":"constant"},{"location":"api/#LightMatter.Constants","page":"API","title":"LightMatter.Constants","text":"Constants = (ħ = 0.6582 eVfs, kB = 8.617e-5 eV/K, me = 5.686 eVm)\n\nGlobal named tuple for accessing constant physical values during a Simulation\n\n\n\n\n\n","category":"constant"},{"location":"api/#LightMatter.LightMatter_units","page":"API","title":"LightMatter.LightMatter_units","text":"LightMatter_units\n\nA list of the units used in LightMatter.jl: Please convert all units to this\n\n\n\n\n\n","category":"constant"},{"location":"api/#System-Construction","page":"API","title":"System Construction","text":"","category":"section"},{"location":"api/#LightMatter.build_backgroundTTM-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.build_backgroundTTM","text":"build_backgroundTTM(sim::Simulation)\n\nBuilds the structs for the TTM to be used in the sub-surface layers of the embedding AthEM nmethod\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Simulation struct setup to perform the background TTM for the embedded AthEM method\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.build_loopbody-Tuple{Any, LightMatter.Simulation}","page":"API","title":"LightMatter.build_loopbody","text":"build_loopbody(sys, sim::Simulation)\n\nBuilds the multi-threaded section of the ODE problem\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Quote block for the multithreaded section of the ODE problem\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.conductivity_expressions-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.conductivity_expressions","text":"conductivity_expressions(sim::Simulation)\n\nCreates vector of expressions for the different conductivities occuring during the simulation\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Vector of expression for the conductivity of each subsytem if they are enabled\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.function_builder-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.function_builder","text":"function_builder(sim::Simulation)\n\nAssembles the correct dictionary of equations for the subsystems that are propagated. Mainly used for\nseperating embedded and un-embedded methods\n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Dictionary of subsystem names and their respective equation / expression\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.generate_expressions-Tuple{LightMatter.Simulation, Expr}","page":"API","title":"LightMatter.generate_expressions","text":"generate_expressions(sim::Simulation, laser::Expr)\n\nCalculates and groups each subsystems expression in turn into a dictionary\n\n# Arguments\n- 'sim': Simulation settings and parameters\n- 'laser': Expression for the temporal evolution and spatial decay of the laser\n\n# Returns\n- Dictionary of subssytems and their respective expressions\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.generate_initialconditions-Tuple{LightMatter.Simulation, Dict{String, Float64}}","page":"API","title":"LightMatter.generate_initialconditions","text":"generate_initialconditions(sim::Simulation, initialtemps::Dict{String, Float64})\n\nGenerates the initial conditions (u0) NamedArrayPartition for the ODE \n\n# Arguments\n- 'sim': Simulation settings and parameters\n- 'initialtemps': Dictionary containing initial temepratures for electronic and phononic baths\n\n# Returns\n- NamedArrayPartition containing the initial conditions of the simulation\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.generate_parameters-Tuple{LightMatter.Simulation, Dict{String, Float64}}","page":"API","title":"LightMatter.generate_parameters","text":"generate_initialconditions(sim::Simulation, initialtemps::Dict{String, Float64})\n\nGenerates the parameters as a NamedTuple for the ODE \n\n# Arguments\n- 'sim': Simulation settings and parameters\n- 'initialtemps': Dictionary containing initial temepratures for electronic and phononic baths\n\n# Returns\n- NamedTuple containing the parameters of the simulation\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.monometallic_system-Tuple{Any, LightMatter.Simulation}","page":"API","title":"LightMatter.monometallic_system","text":"monometallic_system(sys, sim::Simulation)\n\nCreates the expression block for the entire ODE function including multithreading.\nThis function is sepcfically for a monometallic system, Elemental_System == 1\n\n# Arguments\n- 'sys': Dictionary of expressions for each subssytem propagated\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Quote block for the monometallic problem\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.simulation_construction-Tuple{Any, LightMatter.Simulation}","page":"API","title":"LightMatter.simulation_construction","text":"simulation_construction(sys, sim::Simulation)\n\nCreates the expression block for the entire ODE function including multithreading.\nThis function calls monometallic_system or antenna_reactor_system respectively.\n\n# Arguments\n- 'sys': Dictionary of expressions for each subssytem propagated\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Quote block for the entire ODE problem\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.variable_renaming-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.variable_renaming","text":"variable_renaming(sim::Simulation)\n\nRenames variables such as u.x or p.y to just x or y so that during expression evaluation they \nare named correctly. \n\n# Arguments\n- 'sim': Simulation settings and parameters\n\n# Returns\n- Expression for the variabble renaming to enter the top of the multithreaded loop\n\n\n\n\n\n","category":"method"},{"location":"api/#Antenna-Reactor-Construction","page":"API","title":"Antenna-Reactor Construction","text":"","category":"section"},{"location":"api/#LightMatter.antenna_reactor_system-Tuple{Dict{String, Union{Expr, Vector{Expr}}}, LightMatter.Simulation}","page":"API","title":"LightMatter.antenna_reactor_system","text":"antenna_reactor_system(sys, sim)\n\nConstructs the main expression for an antenna reactor simulation system.\n\n# Arguments\n- `sys`::Dict{String, Union{Expr, Vector{Expr}}}\n       A dictionary or configuration object containing the expressions for each system propagated\n- `sim`::Simulation\n       A simulation object containing all necessary input data for the simulation.\n\n# Returns\n- An expression block containing the time output, conductivity expressions, and a threaded simulation loop.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.ar_variable_renaming-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.ar_variable_renaming","text":"ar_variable_renaming(sim)\n\nGenerates variable renaming expressions for translation between the variibale names in DiffEq.jl and LightMatter.jl\n\n# Arguments\n- `sim`::Simulation\n       The Simulation struct containing all information about the simulation\n\n# Returns\n- An expression block assigning simulation-specific variable names.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.mat_picker-Tuple{Float64, Union{Float64, Vector{Float64}}}","page":"API","title":"LightMatter.mat_picker","text":"mat_picker(height, cutoffs)\n\nSelects an index based on material interface height and given cutoffs.\n\n# Arguments\n- `height`::Float64\n          The height value to compare.\n- `cutoffs`::Union{Float64,Vector{Float64}}\n           A vector of cutoff heights defining material regions.\n\n# Returns\n- The index of the region in which `height` lies.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.sim_seperation-Tuple{LightMatter.Simulation}","page":"API","title":"LightMatter.sim_seperation","text":"sim_seperation(sim)\n\nSplits a composite `Simulation` object into separate simulations for each elemental subsystem.\n\n# Arguments\n- `sim`::Simulation\n       The composite simulation containing multiple subsystems.\n\n# Returns\n- A vector of `Simulation` objects, each corresponding to a single elemental subsystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.split_grid-Tuple{Vector{Float64}, Union{Float64, Vector{Float64}}}","page":"API","title":"LightMatter.split_grid","text":"split_grid(grid, cutoffs)\n\nSplits a numerical grid into regions that connect to each material\n\n# Arguments\n- `grid`::Vector{Float64}\n        A vector of Float64 numbers representing the full z-grid\n- `cutoffs`::Union{Float64, Vector{Float64}}\n           A single value or vector of values defining the interfaces between each material \n\n# Returns\n- A vector of sub-vectors representing segments of the original z-grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.split_struct-Tuple{LightMatter.SimulationTypes, Int64}","page":"API","title":"LightMatter.split_struct","text":"split_struct(data, number)\n\nSplits fields of a composite object with vector fields into a vector of scalar instances.\n\n# Arguments\n- `data`::SimulationTypes \n        A subsystem of the simulation e.g. AthermalElectrons or ElectronicTemperature\n- `number`::Int \n          Number of different elemental systems.\n\n# Returns\n- A vector of the subsystem with scalar data extracted from the original vector fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightMatter.split_structure-Tuple{Structure}","page":"API","title":"LightMatter.split_structure","text":"split_structure(structure)\n\nSplits a `Structure` object into multiple structures if `DOS` is a vector. Different to split_struct due to the possibility \nof spatially resolved DOS' though currently that isn't implemented\n\n# Arguments\n- `structure`::Structure\n             The struct containing the information of the simulatkion structure\n\n# Returns\n- A vector of `Structure` objects, one per element if applicable.\n\n\n\n\n\n","category":"method"},{"location":"Tutorials/boltzmann/#boltzmann","page":"Boltzmann Simulation","title":"Boltzmann Simulation","text":"","category":"section"},{"location":"Systems/phononictemperature/#phonon-temperature","page":"Phonon Temperature","title":"Phonon Temperature","text":"","category":"section"},{"location":"Systems/electronictemperature/#electron-temperature","page":"Electronic Temperature","title":"Electronic Temperature","text":"","category":"section"},{"location":"Tutorials/dipoleapproximation/#dipole-approximation","page":"Dipole Approximation Density Matrix Simulation","title":"Dipole Approximation Density Matrix Simulation","text":"","category":"section"},{"location":"Tutorials/athem/#athem","page":"AthEM Simulation","title":"AthEM Simulation","text":"","category":"section"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"In this tutorial we will discuss the theory of the Athermal Electron Model (AthEM). To see more  check out [1]. This model takes the computational efficiency of the TTM but adds a  athermal electron subsystem to simulate electron-hole pairs. The source of the efficiency compared to the Boltzmann equation is the use of the relaxation-time approximation without the lack of energy and particle conservation. This gain in efficiency allows users to do more complex simulations in terms of dimensionality than the Boltzmann equation would allow, e.g. 1D. The discussion on the thermal componets of AthEM will be minimal here as it all follows the same as in the Two-Temperature Model  (TTM) simulation. Here we shall first discuss a 0D AthEM simulation, to see about 1D, check out either the Surface DOS or Antenna-Reactor tutorials. ","category":"page"},{"location":"Tutorials/athem/#Theory-of-AthEM","page":"AthEM Simulation","title":"Theory of AthEM","text":"","category":"section"},{"location":"Tutorials/athem/#Athermal-Electrons","page":"AthEM Simulation","title":"Athermal Electrons","text":"","category":"section"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"The athermal electron subsystem of AthEM, is described in a similar way to the Boltzmann equation for a distribution. In AthEM's case it is written as follows:","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"    fracpartial f^*(E t)partial t = leftfracpartial f^*partial tright_textabsorb + leftfracpartial f^*partial tright_textel^*el + leftfracpartial f^*partial tright_textel^*ph","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"Each of the partial differential's on the right-hand side denotes a scattering term with photons, thermal electrons, and phonons respectively. The athermal electron-athermal electron scattering is set to 0 as in most practical simulations the number of athermal electrons is so small that they are a minor component. ","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"The scattering of the athermal electrons with photons is described by the sum of two Fermi's Golden Rule expressions. One for the hole generation and the other for the electron generation.","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"beginalign\n    leftfracpartial f^*partial tright_textabsorb = leftfracpartial f^*partial tright_texth^+ + leftfracpartial f^*partial tright_texte^-  \n    leftfracpartial f^*partial tright_texth^+ = frac2pi VhbartextDOS(E+hv)M_EE_+^2 f(E)1-f(E+hv)  \n    leftfracpartial f^*partial tright_texte^- = frac2pi VhbartextDOS(E-hv)M_EE_-^2 f(E-hv)1-f(E)\nendalign","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"Here V is the volume of the cell, everything in LightMatter.jl is per nm^3 so this is one in the code's implementation. f(E) is the current total electronic distribution, textDOS is the electronic density-of-states (DOS), hv is the  laser photon frequency and M_EE^2 are matrix elements that are set such that the number of electrons and holes generated are equal as well as that the internal energy of the excitation matches the energy inparted by the laser. In the future there is plans to add further complexity to the matrix elements. The first thing to now notice, is that there is an explicit and unescapable dependence on the DOS. This is unlike the TTM which can use approximations that escape this. Currently there are no keyword arguments that can interact with this component.","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"leftfracpartial f^*partial tright_textel^*el = - fracf^*tau_textee + fracf^texteq - f^textrlxtau_textee","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"Here we have a relaxation time approximation (RTA) in two parts. Firstly, there is the component that sends the  athermal system to 0 (the first component) and the second component drives the equilibrium distribution towards the state with the same internal energy as equilbrium and athermal combined (f^textrlx). This additional effect could be considered as generating the generation of secondary athermal electrons. ","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"The relaxation time itself has a couple of options for electrons. Either a constant (:constant) or Fermi- Liquid Theory (:FLT) relaxation time can be used. The Fermi-Liquid time is considered more acurrate due to the presence of the energy-dependence on the relaxation time.  Both are given below \nAthermal Electron Relaxation Time","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"KWARG Expression/Equation\n:constant :(sim.athermalelectrons.τ)\n:FLT taufracmu^2(E-mu)^2+(pi k_B T_textel)^2\n :(sim.athermalelectrons.τ * (μ+sim.athermalelectrons.FE)^2 ./((sim.structure.egrid.-μ).^2 .+ (pi*Constants.kB*Tel)^2))","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"In the FLT there is a new variable, FE, which isn't in the equation. This variable is the Fermi energy and is defined as the difference between the bottom and top of the  valence band. This can be calculated in LightMatter via FE = FE_initialization(bulk_DOS) where  bulk_DOS is the same string you provided to build_Structure assuming that the DOS Fermi energy is at 0.0 eV. This variable corrects for the the fact that in LightMatter.jl we treat the 0 K μ at 0.0 eV rather than FE. Also, in the case of the FLT, τ now is a material- dependent parameter calculated from, τ = 128  sqrt3piomega_p where omega_p is the plasmon-frequency of the material. This you must provide yourselves. ","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"For the interaction with the phonon system we have,","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"leftfracpartial f^*partial tright_textel^*ph = - fracf^*tau_textep","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"This is similar to the electron-electron RTA but the difference is there is no  driving force on the phonons unlike the thermal electrons. The electron-phonon  relaxation time can only be treated as (:constant). We typically use a relaxation-time derived from, tau_textep = tau_textffthvk_B theta_D where tau_textfft is the free-flight time of electrons and theta_D is the Debye temperature.","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"Now that we have constructed the athermal-electron system let us define how it couples to both of the thermal baths. ","category":"page"},{"location":"Tutorials/athem/#Thermal-Baths","page":"AthEM Simulation","title":"Thermal Baths","text":"","category":"section"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"The equations for how the internal energy of the electronic and phononic thermal systems are very similar between AthEM and the TTM. In 0D they are ","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"    fracpartial u_textel(t)partial t = - g(T_textel + T_textph) + leftfracpartial u_textelpartial tright_textel-el^* \n    fracpartial u_textph(t)partial t = g(T_textel + T_textph) + leftfracpartial u_textphpartial tright_textph-el^* ","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"We have an extra term on the right-hand side which denotes the change in energy from the relaxation with the athermal electrons. The equation for these extra terms are,","category":"page"},{"location":"Tutorials/athem/","page":"AthEM Simulation","title":"AthEM Simulation","text":"    leftfracpartial u_textxpartial tright_textx-el^* = -int leftfracpartial f^*partial tright_textel^*-x textDOS(E) E dE","category":"page"},{"location":"Tutorials/twotemperaturemodel/#ttm","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"","category":"section"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"In this tutorial we will discuss the theory of the Two-Temperature Model(TTM) as well as how to  perform a 1D TTM simulation. Due to the computational efficiency of the TTM, it is advised to perform a 1D simulation where possible as this is the more accurate option. The reason for no 2/3D simulations in LightMatter.jl is that the laser spot size is often much larger than the nanoscale that this package is designed to simulate so we can treat all points in this plane as equal. ","category":"page"},{"location":"Tutorials/twotemperaturemodel/#Theory-of-the-TTM","page":"1D Two-Temperature Model Simulation","title":"Theory of the TTM","text":"","category":"section"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"The equations of motion for the 1D TTM are as follows:","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"beginaligned\nC_textelfracpartial T_textel(z t)partial t = nabla(kappa_textelnabla T_textel) - g(T_textel + T_textph) + S(t) \nC_textphfracpartial T_textph(z t)partial t = nabla(kappa_textphnabla T_textph) + g(T_textel + T_textph)\nendaligned","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"The aim of this method is to treat the two systems as thermal baths rather than electronic distributions. This has the advantage of reducing the computational complexity of propagating a distribution in k or E space into a simple scalar value. However, this takes the assumption that the systems are always in thermal equilibrium with themselves which isn't the case on the  short femtosecond time scale after excitation with a laser pulse. To model this non-equilbrium you need to extend your  level of theory to AthEM or the Boltzmann equation. ","category":"page"},{"location":"Tutorials/twotemperaturemodel/#Thermal-Baths","page":"1D Two-Temperature Model Simulation","title":"Thermal Baths","text":"","category":"section"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"T_textel & T_textph are the electronic and phononic thermal baths respectively. ","category":"page"},{"location":"Tutorials/twotemperaturemodel/#Heat-Capacities","page":"1D Two-Temperature Model Simulation","title":"Heat Capacities","text":"","category":"section"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"C_textel & C_textph are the heat capacities of the electronic and phononic systems. There is a couple of  approximations that can be used when modelling both of these in LightMatter.jl. For the electronic heat capacity, we have a constant (:constant), linear (:linear) and non-linear (:nonlinear) heat capacities, which increase in accuracy in that order. For a phonon heat capacity we have a constant (:constant) and non-linear (:variable) form only. The equations & expressions for all these functions are given below. \n Electronic Heat Capacities","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"KWARG Expression/Equation\n:constant :(sim.electronictemperature.γ)\n:linear :(sim.electronictemperature.γ * T_\\text{el})\n:nonlinear intfracpartial f(Ttext_elμϵ)partial T textDOS(ϵ)ϵ dϵ\n :(LightMatter.nonlinear_electronheatcapacity(Tel, μ, DOS))","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"Both the constant and linear approximations depend on the γ parameter within the electronic temperature whereas the non-linear approximation depends on a density-of-states (DOS) and the chemical potential (μ). To found out more about DOS in LightMatter.jl see the AthEM. μ can be made temperature-dependent by setting ChemicalPotential to true within build_Structure. \n Phononic Heat Capacities","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"KWARG Expression/Equation\n:constant :(sim.phononictemperature.Cph)\n:variable 9nk_B(fracTphθ)^3 *intlimits_0^theta_D x^4 frace^x(e^x-1)^2 dx\n :(LightMatter.variable_phononheatcapacity(Tph, sim.phononictemperature.n, sim.phononictemperature.θ))","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"The constant approximation depends on the parameter Cph the user defines when constructing the phononic thermal bath. In the non-linear case, we use Simpson's rule to determine the heat capacity and this depends on the Debye temperature (θ) and the number of atoms per nm^3 (n). The Boltzmann constant is a constant within LightMatter.jl so is handled for you. To see more check out Unit Handling.","category":"page"},{"location":"Tutorials/twotemperaturemodel/#Electron-Phonon-Coupling","page":"1D Two-Temperature Model Simulation","title":"Electron-Phonon Coupling","text":"","category":"section"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"g is the electorn-phonon coupling constant in the TTM. This parameter can be either a constant(:constant) provided  during construction or a non-linear parameter (:variable) calculated each time-step. \n Electron-Phonon Coupling Constant","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"KWARG Expression/Equation\n:constant :(sim.electronictemperature.g)\n:variable frack_BλωtextDOS(μ)ħint textDOS(ϵ)^2 fracpartial f(T_textel μ ϵ)partial E dϵ\n :(LightMatter.variable_electronphononcoupling(sim.electronictemperature.λ, sim.electronictemperature.ω, DOS, Tel, μ, Tph, sim.structure.egrid))","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"The new parameters in the :variable approximation are the electron-phonon mass enhancement factor (λ) and the second moment of the phonon spectrum (ω). To found out more check out [2].","category":"page"},{"location":"Tutorials/twotemperaturemodel/#Laser","page":"1D Two-Temperature Model Simulation","title":"Laser","text":"","category":"section"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"The laser input is defined as S(t) in the equations at the top. It only directly interacts with the electronic system. To find out about the possible lasers see, Lasers.","category":"page"},{"location":"Tutorials/twotemperaturemodel/#Thermal-Conductivity","page":"1D Two-Temperature Model Simulation","title":"Thermal Conductivity","text":"","category":"section"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"The thermal conductivity in LightMatter.jl is restricted to only the z-axis as currently 2/3D models are not possible. This means that nabla represents fracpartialpartial z. The gradients are calculated via finite difference, primarily central difference except at the edges. The thermal conductivity (κ) for electrons and phonons is treated differently. \nElectrons \nkappa or sim.electronictemperature.κ represents the room temperature thermal conductivity of the electrons and  is scaled temperature dependetly during the simulation via κ_textfinal = kappa_textrtfracT_textelT_textph. The phonon thermal conductivity however is treated as a constant. Currently there are no other options but in the future this may change. ","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"","category":"page"},{"location":"Tutorials/twotemperaturemodel/#Example-Simulation","page":"1D Two-Temperature Model Simulation","title":"Example Simulation","text":"","category":"section"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"Now that all the theory and approximations of the TTM have been discussed, at least in the context of LightMatter.jl, we will perform a couple of example simulations to show how to run a 1D simulation, the effect this has on temperatures compared to a 0D simulation, even at nanofilm thicknesses and also discuss the effect of the different approximations we can invoke. ","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"note: Note\nIf you want to see a simple 0D Two-Temperature Model (TTM) then please check out Getting Started.","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"We  are going to use the highest level of approximation for this simulation of a 30nm gold film. Due to the computational  efficiency of the TTM there is no harm in performing the simulation at this level. In addition, heat capacities and electron -phonon couplings can be very temperature dependent and unless you know that your material is not in the temperature  window of your simulation it is best to calculate them explicitly. ","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"First let's define everything we need outside of the thermal baths.","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"    Dim = build_Dimension(collect(0.0:0.5:30.0))\n    Struc = build_Structure(dimension=Dim, chemicalpotential = true, bulk_DOS=\"DOS/Au_DOS.dat\", \n                            bulk_geometry = \"DOS/Au_geometry.in\")\n    Las = build_Laser(envelope=:Gaussian, FWHM=50.0u\"fs\", ϕ=10.0u\"J/m^2\", Transport=:optical, ϵ=16.3e-9u\"m\")","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"Here, we have defined a spatial grid to solve the problem on, this is done by giving a vector to build_Dimension. Next we have provided that struct to the Structure struct as well as defined that we want the chemical potential to update with repsect to the electronic temperature. We have also provided a location to find the DOS and a  geometry file that was used to calculate the DOS. Finally, we have built a very simple Gaussian laser, the same as the one used in Getting Started.","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"note: Note\nAll automatic implementations of DOS assembly (interpolation) assume that the DOS and geometry are in the FHI-AIMS format. There is an aim to make an automatic conversion in the future but if this is not the case then you can supply your own spline fit to the DOS KWARG in build_Structure. To ensure type stability use LightMatterget_interpolant(energy states) to create the spline and make sure that the units of your DOS are states/eVnm³.","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"Next let's build our thermal baths.","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"    Tel = build_ElectronicTemperature(Enabled = true, Electron_PhononCoupling = true, Conductivity = true,\n                                      ElectronicHeatCapcity = :nonlinear, ElectronPhononCouplingValue = :variable,\n                                      κ = 278u\"J/s/m/K\", λ = 0.18, ω = 13e-4u\"eV^2\")\n    Tph = build_PhononicTemperature(Enabled = true, Electron_PhononCoupling = true, Conductivity = true,\n                                    PhononicHeatCapacity = :variable, κ = 2u\"J/s/m/K\", θ = 162.3u\"K\", n = 59.0u\"nm^-3\")","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"We can now go onto build our Simulation by bringing all this together.","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"    Sim = build_Simulation(electronictemperature = Tel, phononictemperature = Tph, laser = Las, structure = Struc)","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"And finally, after defining some initial conditions we can run the simulation","category":"page"},{"location":"Tutorials/twotemperaturemodel/","page":"1D Two-Temperature Model Simulation","title":"1D Two-Temperature Model Simulation","text":"    initialtemps=Dict(\"Tel\"=>300.0,\"Tph\"=>300.0)\n    tspan=(-150.0, 1000.0)  \n    sol = run_simulation(Sim, initialtemps, tspan, saveat=1.0, abstol=1e-10, reltol=1e-10)","category":"page"},{"location":"Systems/athermalelectrons/#athermal-electrons","page":"Athermal Electrons","title":"Athermal Electrons","text":"","category":"section"},{"location":"Systems/structure/#structure","page":"Structure","title":"Structure","text":"","category":"section"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the docuemntation for the light-matter interaction package LightMatter.jl. The documentation will cover all aspectsof using the code including how to setup simulations, the different systems and approximations that you can choose to implement as well as a tutorial on how to include your own further approximations into a simulation. We will also try to cover how to perform all calculations that we have previosuly published and hope that you contribute to keep the package as useful to the community as possible.","category":"page"},{"location":"#Objectives-of-the-code","page":"Introduction","title":"Objectives of the code","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"High performance light-matter simulations at a range of theories\nProvide a toolkit of methods/approximations to build the simulation you desire\nIntegrate easily with other great tools found in Julia\nTo be an open-source, code-available software for the whole light-matter community.","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Here we provide a list of currently implemented features of the code. We encourage contributions and extensions of the current methods available","category":"page"},{"location":"#Systems","page":"Introduction","title":"Systems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Electronic Thermal Bath\nPhononic Thermal Bath\nAthermal Electron Subsystem\nElectronic Distribution\nPhononic Distribution\nDensity Matrix Dynamics","category":"page"},{"location":"#Spatial-Features","page":"Introduction","title":"Spatial Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"0 or 1D simulations: For a simple example see Two-Temperature Model\nSpatially resolved density of states\nSimulating complex systems","category":"page"},{"location":"#Dynamics-with-DifferentialEquations.jl","page":"Introduction","title":"Dynamics with DifferentialEquations.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The DifferentialEquations ecosystem from the SciML organisation provides a large library of time integration algorithms. All dynamics propagation is driven by these algorithms and we provide full support for all ordinary differential equation methods provided within the 'OrdinaryDiffEq.jl package. ","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#1.-Install-Julia","page":"Introduction","title":"1. Install Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Download and install the current stable release from the Julia website. For most platforms Julia is provided as a precompiled binary and do not require any installation procedure. However, you need to specify the path to julia or create a symbolic link to the executable that is in your systempath. Juliaup is the recommended and easiest way to manage Julia versions and have a smooth installation experience.","category":"page"},{"location":"#2.-Install-the-package","page":"Introduction","title":"2. Install the package","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package can be installed in the same way as any other registered Julia package:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add LightMatter","category":"page"},{"location":"#4.-Use-the-package!","page":"Introduction","title":"4. Use the package!","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using LightMatter","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You are now free to proceed to the next section and learn how to use the package. If you would like you can complete step 5 to double check your installation.","category":"page"},{"location":"#5.-Run-the-tests-(optional)","page":"Introduction","title":"5. Run the tests (optional)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To check the package has been installed correctly and everything is working, you can execute the tests with:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> test LightMatter","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nThe tests that ship with this package are currently being developed and greatly expanded upon.","category":"page"},{"location":"#How-to-use-this-documentation","page":"Introduction","title":"How to use this documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The first page to read is the Getting started section which walks through all the ingredients needed to perform a classical Two-Tempreature Model simulation.  After this, the reader is free to explore at their leisure since everything else builds directly upon sections from the Getting started page.","category":"page"},{"location":"Systems/phononicdistribution/#phonon-distribution","page":"Phononic Distribution","title":"Phononic Distribution","text":"","category":"section"}]
}
